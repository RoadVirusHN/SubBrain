<!DOCTYPE html>
<html lang="kr"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>DKT 기본 | The Digital garden of Nurgle.</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="DKT 기본" />
<meta property="og:locale" content="kr" />
<meta name="description" content="style: number min_depth: 2 max_depth: 3 varied_style: true 심층 지식 탐색(Deep Knowledge Tracing, DKT) 기본" />
<meta property="og:description" content="style: number min_depth: 2 max_depth: 3 varied_style: true 심층 지식 탐색(Deep Knowledge Tracing, DKT) 기본" />
<link rel="canonical" href="http://localhost:4000/articles/AI/Structured_Data/DKT%20%EA%B8%B0%EB%B3%B8.html" />
<meta property="og:url" content="http://localhost:4000/articles/AI/Structured_Data/DKT%20%EA%B8%B0%EB%B3%B8.html" />
<meta property="og:site_name" content="The Digital garden of Nurgle." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-12-14T13:41:08+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="DKT 기본" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-12-14T13:41:08+09:00","datePublished":"2022-12-14T13:41:08+09:00","description":"style: number min_depth: 2 max_depth: 3 varied_style: true 심층 지식 탐색(Deep Knowledge Tracing, DKT) 기본","headline":"DKT 기본","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/articles/AI/Structured_Data/DKT%20%EA%B8%B0%EB%B3%B8.html"},"url":"http://localhost:4000/articles/AI/Structured_Data/DKT%20%EA%B8%B0%EB%B3%B8.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="The Digital garden of Nurgle." /></head>
<div class="scrollWrapper">
  <div class="scrollbar"></div>
  <div class="progressbar"></div>
  <div class="scrollbarButton"></div>
</div>

<link rel="stylesheet" href="/assets/css/obsidian/obs-scrollbar.css" />

<!--<div class="redirection">
  <h1 class="name">Redirection for full experience.</h1>
  <br>
  Move to <br /> <a class="to" href="#">netlify url</a><br />
  <div>after <span class="counter">10</span>secs.</div>
  press <button class="cancle">here</button> to cancle.
</div>
<div class="overlay"></div>
<script type="module" src="/assets/scripts/common/components/init_redirection.js"></script>

<link rel="stylesheet" href="/assets/css/common/redirection.css" />-->

<body><header class="site-header" role="banner">

  <div class="wrapper" style="display: flex; justify-content: space-between;"><div id="header-wrapper">
    <a class="site-title" rel="author" href="/blog">The Digital garden of Nurgle.</a>

    </div><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><script src="https://unpkg.com/lunr/lunr.js"></script>
<link rel="stylesheet" href="/assets/css/common/searchbar.css" />

<form id="search-form" method="get">
  <span id="search-wrapper">
    <span id="tag-holder" ></span>
    <input type="text" id="search-box" placeholder='Prefix "#" to add Tag.' autocomplete="off">
    <span class="inner-search" >🔍</span>
  </span>
</form><a class="page-link" href="/">ABOUT ME</a><a class="page-link" href="/blog">ALL ARTICLES</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
    <link rel="stylesheet" href="/assets/css/common/drawer.css" />
<button class="drawer-button open">▶️</button>
<div id="drawer" class="close">
  <button class="drawer-button close">
    ◀️
  </button>
  <div class="drawer-content">
    <div class="my-description">
      <div class="avatar-section" style="display: flex; flex-direction: row;">

        <img src="/assets/img/common/avatar.png" alt="avatar" class="avatar">
        <div style="display: flex; flex-direction: column; margin-left: 5px;">
          <a href="/about/">
            <h3 class="name">ROADVIRUSHN</h3>
          </a>
          <div class="stack-list" style="margin: 5px 0 0 5px;">
            <a title="My github page" href="https://github.com/RoadVirusHN">
  <svg class="svg-icon" width="16" height="16" viewBox="0 0 16 16">
    <use xlink:href="/assets/svg/social-icons.svg#github"></use>
  </svg>
</a>
<a title="My G-mail" href="mailto:roadvirushn@gmail.com">
  <svg class="svg-icon" width="16" height="16" viewBox="0 0 16 16">
    <use xlink:href="/assets/svg/social-icons.svg#gmail"></use>
  </svg>
</a>
<a title="My Blog" href="https://luminous-bubblegum-8e9be4.netlify.app">
  <svg class="svg-icon" width="16" height="16" viewBox="0 0 16 16">
    <use xlink:href="/assets/svg/social-icons.svg#blog"></use>
  </svg>
</a>
          </div>
        </div>
        <!-- <h4 class="name">(JUNSEOK YUN)</h4> -->
      </div>
      <p style="margin: 5px 0 0 0;">
        풀스택 웹🌐 개발자 지망생 🧑🏽‍💻
        <br>
        ➕ 인공지능 관심 🤖
      </p>
    </div>
      <hr>
      <div class="categories">
        <h3 style="margin: 0;"><a href="/">Categories</a></h3>
        <ul class="category-list">
  
  
  
  <li>
    <strong style="font-size: larger;">┣ </strong>
    <h3 style="display: inline;">
      
      <span class="category-drop-down">▶</span>
      
      <a class="category-link" href="/categories/COMPUTER_SCIENCE/" >COMPUTER_SCIENCE</a>
    </h3>
    <span style="font-size: xx-small;">
       
      📂: 5
    </span>
    <ul class="child-category-list">
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/DATABASE/">DATABASE</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/ALGORITHM/">ALGORITHM</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 15 
            📂: 1
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/OS/">OS</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 14 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/NETWORK/">NETWORK</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 8 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┗ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/ETC/">ETC</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
    </ul>
  </li>
  
  
  <li>
    <strong style="font-size: larger;">┣ </strong>
    <h3 style="display: inline;">
      
      <span class="category-drop-down">▶</span>
      
      <a class="category-link" href="/categories/WEB/" >WEB</a>
    </h3>
    <span style="font-size: xx-small;">
       
      📂: 3
    </span>
    <ul class="child-category-list">
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/WEB/FRONTEND/">FRONTEND</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/WEB/BACKEND/">BACKEND</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 5 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┗ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/WEB/CI,CD/">CI,CD</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            📂: 2
          </span>
      </li>
      
    </ul>
  </li>
  
  
  <li>
    <strong style="font-size: larger;">┣ </strong>
    <h3 style="display: inline;">
      
      <a class="category-link" href="/categories/ETC/" >ETC</a>
    </h3>
    <span style="font-size: xx-small;">
      📄: 9 
      
    </span>
    <ul class="child-category-list">
      
    </ul>
  </li>
  
  
  <li>
    <strong style="font-size: larger;">┗ </strong>
    <h3 style="display: inline;">
      
      <span class="category-drop-down">▶</span>
      
      <a class="category-link" href="/categories/AI/" >AI</a>
    </h3>
    <span style="font-size: xx-small;">
       
      📂: 9
    </span>
    <ul class="child-category-list">
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/AITOOLS/">AITOOLS</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 3 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/CV/">CV</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/DEEP_LEARNING/">DEEP_LEARNING</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/DATA_VIS/">DATA_VIS</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/GRAPH/">GRAPH</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/LIGHTWEIGHT/">LIGHTWEIGHT</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/MATH/">MATH</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/NLP/">NLP</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 3 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┗ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/STRUCTURED_DATA/">STRUCTURED_DATA</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            
          </span>
      </li>
      
    </ul>
  </li>
  
</ul>
      </div>
      <hr>
      <div class="recent-view">
        <h3 style="margin: 0;">Recent views</h3>
        <ul style="margin: 0;">
          <li>
            <strong style="color:rgb(219, 219, 12);">1 <a id="recent-1"></a></strong>
          </li>
          <li>
            2 <a id="recent-2"></a>
          </li>
          <li>
            3 <a id="recent-3"></a>
          </li>
          <li>
            4 <a id="recent-4"></a>
          </li>
          <li>
            5 <a id="recent-5" style="overflow: hidden;"></a>
          </li>
        </ul>
      </div>
    </div>
    <hr>
  <div style="height: 7vh;"></div>
</div>
    <div class="wrapper">
      <article class="article h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="article-header">
    <h1 class="article-title a-name" itemprop="name headline">DKT 기본</h1>
    <p class="article-meta">
      <time class="dt-published" datetime="2022-12-14T13:41:08+09:00" itemprop="datePublished">Dec 14, 2022
      </time></p>
  </header>

  <div class="article-content e-content" itemprop="articleBody">
     
  
<script>
  MathJax = {
    tex: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"],
      ],
    },
    svg: {
      fontCache: "global",  
     // scale: 1.5,
    },
    chtml: {
     // scale: 1.5,
    },
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>
 
 


<script src="/assets/scripts/bundle/obsidian.bundle.js"></script>
<link rel="stylesheet" href="/assets/css/obsidian/callout.css" />
<link rel="stylesheet" href="/assets/css/obsidian/image.css" />
<link rel="stylesheet" href="/assets/css/obsidian/link-warning.css" />
<link rel="stylesheet" href="/assets/css/obsidian/preview.css" />

<div class="content-section">
  
<ol id='markdown-toc-0'>
<li><a href='#DKT-이해-및-DKT-Trend-소개' id='markdown-toc-0-DKT-이해-및-DKT-Trend-소개'>DKT 이해 및 DKT Trend 소개</a><ul><li><a href='#DKT-Task-이해' id='markdown-toc-0-DKT-Task-이해'>DKT Task 이해</a></li> 
<li><a href='#Metric-이해' id='markdown-toc-0-Metric-이해'>Metric 이해</a><ul>
</ul></li> 
<li><a href='#DKT-History-및-Trend' id='markdown-toc-0-DKT-History-및-Trend'>DKT History 및 Trend</a></li> 

</ul></li> 
<li><a href='#DKT-Data-Exploratory-Data-Analysis' id='markdown-toc-0-DKT-Data-Exploratory-Data-Analysis'>DKT Data Exploratory Data Analysis</a><ul><li><a href='#i-Scream-데이터-분석' id='markdown-toc-0-i-Scream-데이터-분석'>i-Scream 데이터 분석</a><ul>
</ul></li> 
<li><a href='#Hands-on-EDA' id='markdown-toc-0-Hands-on-EDA'>Hands on EDA</a></li> 
<li><a href='#Sequence-모델링' id='markdown-toc-0-Sequence-모델링'>Sequence 모델링</a></li> 

</ul></li> 
<li><a href='#Sequence-Data-문제-정의에-맞는-Transformer-Architecture-설계' id='markdown-toc-0-Sequence-Data-문제-정의에-맞는-Transformer-Architecture-설계'>Sequence Data 문제 정의에 맞는 Transformer Architecture 설계</a><ul><li><a href='#Data-Science-Bowl' id='markdown-toc-0-Data-Science-Bowl'>Data Science Bowl</a></li> 
<li><a href='#Riid' id='markdown-toc-0-Riid'>Riid!</a></li> 
<li><a href='#Predicting-Molecular-Properties' id='markdown-toc-0-Predicting-Molecular-Properties'>Predicting Molecular Properties</a></li> 
<li><a href='#Mechanisms-of-Actions-MoA' id='markdown-toc-0-Mechanisms-of-Actions-MoA'>Mechanisms of Actions (MoA)</a></li> 

</ul></li> 
<li><a href='#Kaggle-Riiid-Competition-Winner’s-Solution-탐색' id='markdown-toc-0-Kaggle-Riiid-Competition-Winner’s-Solution-탐색'>Kaggle Riiid Competition Winner’s Solution 탐색</a><ul><li><a href='#Feature-Engineering' id='markdown-toc-0-Feature-Engineering'>Feature Engineering</a><ul>
</ul></li> 
<li><a href='#Last-Query-Transformer-RNN' id='markdown-toc-0-Last-Query-Transformer-RNN'>Last Query Transformer RNN</a></li> 

</ul></li> 
<li><a href='#ML-Pipeline' id='markdown-toc-0-ML-Pipeline'>ML Pipeline</a></li> 
<li><a href='#Model-Serving' id='markdown-toc-0-Model-Serving'>Model Serving</a><ul><li><a href='#모델-서빙의-종류' id='markdown-toc-0-모델-서빙의-종류'>모델 서빙의 종류</a></li> 
<li><a href='#웹서버를-활용한-모델-서빙' id='markdown-toc-0-웹서버를-활용한-모델-서빙'>웹서버를 활용한 모델 서빙</a><ul>
</ul></li> 
<li><a href='#MLflow를-활용한-모델-서빙' id='markdown-toc-0-MLflow를-활용한-모델-서빙'>MLflow를 활용한 모델 서빙</a><ul>
</ul></li> 

</ul></li> 
<li><a href='#End-to-End-Project' id='markdown-toc-0-End-to-End-Project'>End to End Project</a><ul><li><a href='#실제-현업과-Competition의-비교' id='markdown-toc-0-실제-현업과-Competition의-비교'>실제 현업과 Competition의 비교</a></li> 
<li><a href='#문제정의-3요소' id='markdown-toc-0-문제정의-3요소'>문제정의 3요소</a></li> 
<li><a href='#Workflow' id='markdown-toc-0-Workflow'>Workflow</a><ul>
</ul></li> 

</ul></li> 
</ol>
<h1 id='심층-지식-탐색-Deep-Knowledge-Tracing-DKT-기본'>심층 지식 탐색(Deep Knowledge Tracing, DKT) 기본</h1>

<blockquote>
  <p>Naver AI boostcamp DKT 강의를 정리한 내용입니다.</p>
</blockquote>

<h2 id='DKT-이해-및-DKT-Trend-소개'>DKT 이해 및 DKT Trend 소개</h2>

<h3 id='DKT-Task-이해'>DKT Task 이해</h3>

<p><img src="/assets/img/DKT 기본/image-20210524130500177.png" alt="" /></p>

<p>DKT (DEEP KNOWLEDGE TRACING) : 딥러닝을 이용하는 지식 상태 추적</p>

<p><img src="/assets/img/DKT 기본/image-20210524125829442.png" alt="" /></p>

<p>Question과 Response로 이루어진 문제 풀이 정보를 통해 다음 지식상태(주로 문제를 풀 수 있는가?)를 예측하는 방식으로 진행된다.</p>

<ul>
  <li>즉, 주어진 문제를 맞췄는 지 틀렸는지 알아보는 Binary Classification 문제이기도 하다.</li>
</ul>

<p>지식 상태는 계속 변화하므로 지속적으로 추적해야 한다.</p>

<p>보통 문제와 풀이 결과를 Train set으로,</p>

<p>마지막 문제의 풀이 결과가 masking 되있는 문제들과 풀이결과가 Test set으로 주어진다.</p>

<p>문제 풀이 정보(데이터)가 추가될 수록 학생의 지식 상태를 더 정확히 예측 가능.</p>

<p>데이터가 적을 수록 오버피팅 현상이 쉽게 일어난다.</p>

<h3 id='Metric-이해'>Metric 이해</h3>

<h4 id='AUC-ACC-Area-under-the-roc-curve-Accuracy'>AUC/ACC(Area under the roc curve/Accuracy)</h4>

<p><img src="/assets/img/DKT 기본/image-20210524130858408.png" alt="" /></p>

<p>보통 예측의 결과는 float 형태로 나오며, 0.5(Threshold)를 기준으로 정답 여부(1,0)를 결정한다.</p>

<p><img src="/assets/img/DKT 기본/image-20210524131142025.png" alt="" /></p>

<h4 id='Confusion-Matrix-혼동행렬-의-이해'>Confusion Matrix(혼동행렬)의 이해</h4>

<p><img src="/assets/img/DKT 기본/image-20210524131556645.png" alt="" /></p>

<p><strong>Predicted</strong> : 모델의 예측값</p>

<p><strong>Actual</strong>: 실제 값</p>

<p><strong>Accuracy</strong>: 전체 중 예측값과 맞는 비율</p>

<p><strong>Precision(PPV, Positive predictive value)</strong> : 모델이 맞다고 예측한 비율 중 실제 맞은 비율</p>

<p><strong>Recall,Sensitivity (True positive rate(TPR))</strong>: 실제 1인 비율 중에 모델이 1이라고 한 비율</p>

<p><strong>Specificity</strong> : 실제 0인 비율 중에 모델이 0이라고 한 비율</p>

<p><strong>F1 score</strong> : Prescision과 Recall의 절충안, 동시에 고려함.</p>

<p>다만 위의 metric 들은 Threshold에 영향을 받게됨(여기서는 0.5)</p>

<h4 id='AUC-Area-under-the-roc-curve'>AUC(Area under the roc curve)</h4>

<p><img src="/assets/img/DKT 기본/image-20210524132901432.png" alt="" /></p>

<p>그래프의 면적이 커질수록 성능이 더 좋아진다.</p>

<p>AUC 값의 범위는 0~1이며, 랜덤하게 0과 1을 넣은 경우 0.5이다.</p>

<p>AUC는 척도 불면, 절대 값이 아니라 예측이 얼마나 잘 평가되는지 측정하는 것이며(예측값들의 절대적인 크기와 관계없음),</p>

<p>분류 임계값 불변, 어떤 분류 임계값이 선택되었는지와 상관없이 모델의 예측 품질을 측정할 수 있다. (Threshold 관계 없음)</p>

<p>단, 단점들로,</p>

<p>척도 불변이 항상 이상적이지 않을 수 있다. 예를 들어, 0.9 이상의 값이 중요할 경우 AUC로 측정 불가</p>

<p>분류 임계값 불변이 항상 이상적이지 않다. 예를 들어 허위 양성(FP) 최소화가 더욱 중요한 경우(중요한 메일이 지워지면 안되는 스팸메일 분류 등) 이럴 때는 AUC가 유용한 측정항목이 아니다.</p>

<p>imbalanced data에서는 accuracy 보다는 낫지만, AUC가 비교적 높게 측정되는 경향이 있다.</p>

<p>(단, Test data가 동일할 경우, 상대적인 성능 비교는 가능하다)</p>

<p><img src="/assets/img/DKT 기본/image-20210524133343483.png" alt="" /></p>

<p>FPR은 Specificity를 의미하며, TPR은 Recall을 의미한다.</p>

<p><img src="/assets/img/DKT 기본/image-20210524133619924.png" alt="" /></p>

<p>결과값에 따라 다음과 같은 방법으로 ROC curve를 그릴 수 있다.</p>

<p><img src="/assets/img/DKT 기본/image-20210524134737191.png" alt="" /></p>

<p><img src="/assets/img/DKT 기본/image-20210524134808082.png" alt="" /></p>

<p>위와 같이 Threshold 지점을 중심으로 겹치는 부분 (=예측이 틀린 부분)이 적을수록 ROC Curve의 면적이 넓어지고, 성능이 좋다는 의미이다.</p>

<h3 id='DKT-History-및-Trend'>DKT History 및 Trend</h3>

<p>ML, DL, Transformer, GNN 등의 DKT의 트랜드가 발전해 왔다.</p>

<p><img src="/assets/img/DKT 기본/image-20210524141306210.png" alt="" /><br />
[1강 참고 자료, History of deep knowledge tracing 참조]</p>

<h2 id='DKT-Data-Exploratory-Data-Analysis'>DKT Data Exploratory Data Analysis</h2>

<p>DKT Datset EDA에 대한 예시</p>

<h3 id='i-Scream-데이터-분석'>i-Scream 데이터 분석</h3>

<p><img src="/assets/img/DKT 기본/image-20210524143940935.png" alt="" /></p>

<p>i-Scream edu에서 제공하는 Dataset</p>

<p>feature로 userID, assessmentItemID, testId, answerCode, Timestamp, KnowledgeTag로 이루어짐.</p>

<p>DKT에서 보통 하나의 행을 Interaction이라고 부름</p>

<p><strong>userID</strong></p>

<ul>
  <li>사용자 별 고유번호, 총 7442명의 고유한 사용자 존재</li>
</ul>

<p><strong>assessmentItemID</strong></p>

<ul>
  <li>사용자가 푼 문항의 일련 번호, 총 9454개의 고유한 문항이 존재</li>
  <li>총 10자리로 구성, 첫자리는 항상 알파멧 A, 그다음 6자리는 시험지 번호, 마지막 3자리는 시험지 내 문항의 번호로 구성</li>
  <li>ex) A030071005</li>
</ul>

<p><strong>testId</strong></p>

<ul>
  <li>사용자가 푼 문항이 포함된 시험지의 일련 번호, 총 1537개의 고유한 시험지가 존재</li>
  <li>총 10자리로 구성, 첫 자리는 항상 알파멧 A, 그 다음 9자리 중 앞의 3자리와 끝의 3자리가 시험지 번호, 가운데 3자리는 모두 000</li>
  <li>앞의 3자리 중 가운데 자리는 1~9값을 가지며 이를 대분류로 사용 가능</li>
  <li>ex) A030000071</li>
</ul>

<p><strong>answerCode</strong></p>

<ul>
  <li>사용자가 문항을 맞았는 지 여부를 담은 이진 데이터, 0은 틀림, 1은 맞음</li>
  <li>전체 Interaction에 대해 65.45%가 정답을 맞춤, 즉 조금 불균형한 데이터셋</li>
</ul>

<p><strong>Timestamp</strong></p>

<ul>
  <li>사용자가 Interaction을 시작한 시간 정보, 시간 간격을 통해 문제를 푸는 시간을 가늠할 수 있음.</li>
</ul>

<p><strong>KnowledgeTag</strong></p>

<ul>
  <li>문항 당 하나씩 배정되는 태그, 일종의 중분류</li>
  <li>총 912개의 고유 태그 존재</li>
</ul>

<h4 id='기술-통계량-분석'>기술 통계량 분석</h4>

<p><strong>기술 통계량?</strong></p>

<ul>
  <li>일반적으로 데이터를 살펴볼 때, 가장 먼저 살펴보는 것은 기술 통계량입니다.</li>
  <li>보통 데이터 자체의 정보를 수치로 요약, 단순화하는 것을 목적으로 하며</li>
  <li>우리가 잘 알고 있는 평균, 중앙값, 최대/최소와 같은 값들을 찾아내고, EDA 과정에서는 이들을 유의미하게 시각화하는 작업을 거침</li>
  <li>분석은 최종 목표인 정답률과 연관 지어 진행하는 것이 유리</li>
</ul>

<p>다음은 I-scream dataset의 특성 별 빈도 분석 종합이다.</p>

<p><img src="/assets/img/DKT 기본/image-20210524145959390.png" alt="" /></p>

<p>다음은 I-scream dataset의 특성 별 정답률 분석 종합이다.</p>

<p><img src="/assets/img/DKT 기본/image-20210524150009838.png" alt="" /></p>

<p>위와 같은 단순 기술 통계량을 넘어서, 얻어낸 특성과 정답률 사이의 관계를 분석해야 하며, 이때, 여러 지식과 경험이 있으면 좋다.</p>

<p>예를 들어, 문제를 많이 푼 사람이 문제를 더 잘 맞추는가?, 좀더 자주 나오는 태그의 문제의 정답률이 높은가?, 문항을 푸는데 걸린 시간과 정답률의 관계는 어떠한가?</p>

<p><img src="/assets/img/DKT 기본/image-20210524151032120.png" alt="" /><img src="/assets/img/DKT 기본/image-20210524151037369.png" alt="" /></p>

<p>문항을 더 많이 푼 학생이 문제를 더 잘맞추는 경향이 있다.</p>

<p><img src="/assets/img/DKT 기본/image-20210524151240408.png" alt="" /></p>

<p>문항을 풀수록 한 학생의 정답률이 늘어나는 경향이 있는가?에 대한 그래프이다. 주로 초반에 잘 푼 학생은 점점 감소하며, 반대의 경우 점점 증가한다.</p>

<p>전반적으로 증가하는 추세이다.</p>

<p>이외에도 같은 시험지나 태그의 문제를 연달아 풀면 정답률이 오르는가? 등을 생각해볼 수 있다.</p>

<h3 id='Hands-on-EDA'>Hands on EDA</h3>

<p>[Lab. ]</p>

<h3 id='Sequence-모델링'>Sequence 모델링</h3>

<p>정형데이터에는 Titanic 처럼 Time과 관계없는 Non-Sequential Data와, Transaction처럼 시간의 순서가 존재하는 Sequential Data가 존재한다.</p>

<p><img src="/assets/img/DKT 기본/image-20210526000703733.png" alt="" /></p>

<p>이때, Sequential Data를 Time을 통합하고 특정 feature에 맞춰 집계하거나 그대로 둔채로 추가 feature를 생성하는 방식으로 Feature Engineering이 가능하다.</p>

<p><img src="/assets/img/DKT 기본/image-20210526001425253.png" alt="" /></p>

<p>예를 들어, 문제, 시험, 또는 사람 별로 집계한 뒤, 정답 확률 feature를 추가할 수 있다.</p>

<p>이러한 feature들은 hyperparameter 처럼 추가, 삭제를 통해 모델의 성능을 확인할 수 있다.</p>

<p><img src="/assets/img/DKT 기본/image-20210526003455839.png" alt="" /></p>

<p>이때, 단순히 이벤트의 행 단위로 개수를 세지 않고, aggregation 기준을 중심으로 split 해야된다.</p>

<p><img src="/assets/img/DKT 기본/image-20210527072447707.png" alt="" /></p>

<p>그 이후, feature와 hyperparameter를 바꿔가면서 성능의 차이를 알아보며 feature를 결정한다.</p>

<p><img src="/assets/img/DKT 기본/image-20210527080437216.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">torch</span>
<span class="n">importh</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span> <span class="k">as</span> <span class="n">nn</span>

<span class="c1"># Size: [batch_size, seq_len, input_size or num_of_features]
</span><span class="nb">input</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">lstm</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">LSTM</span><span class="p">(</span><span class="n">input_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">hidden_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">batch_first</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">output</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">lstm</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="n">output</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="c1"># =&amp;#38;#62; torch.Size([3, 5, 2]), batch_size, seq_len, hidden_size)
</span>
</code></pre></div></div>
<p>LSTM 구조의 Sequece input은 다음과 같이 이루어진다.</p>

<p>batch size(dataset chunk 한 크기), seq_len(sequence의 길이), input_size(4 차원 embedding) or num_of_features의 3차원 벡터가 들어간 뒤,</p>

<p>batch_size, seq_len, hiddensize(hyperparameter)의 output이 나온다.</p>

<p><img src="/assets/img/DKT 기본/image-20210527084410498.png" alt="" /></p>

<p>feature의 수에 따라 input size가 변하는 예시를 보자면 위와 같다.</p>

<p><img src="/assets/img/DKT 기본/image-20210527080940053.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">config</span> <span class="o">=</span> <span class="n">BertConfig</span><span class="p">(</span>
 <span class="mi">3</span><span class="p">,</span> <span class="c1"># vocab_size, not used
</span> <span class="n">hidden_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">num_attention_heads</span><span class="o">=</span><span class="mi">1</span>
 <span class="p">)</span>
 
 <span class="c1"># Size: [batch_size, seq_len, input_size]
</span> <span class="nb">input</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
 <span class="c1"># Size: [batch_size, seq_len]
</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
 
 <span class="n">transformer</span> <span class="o">=</span> <span class="n">BertModel</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
 <span class="n">encoded_layers</span> <span class="o">=</span> <span class="n">transformer</span><span class="p">(</span><span class="n">inputs_embeds</span><span class="o">=</span><span class="nb">input</span><span class="p">,</span> <span class="n">attention_mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
 <span class="n">sequence_output</span> <span class="o">=</span> <span class="n">encoded_layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
 <span class="n">sequence_output</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="c1">#=&amp;#38;#62; torch.Size([batch_size, seq_len, input_size])
</span> 
</code></pre></div></div>
<p>Transformer의 input과 output 또한 크게 다르지 않지만, masking의 차원이 1차원 적다.</p>

<p><img src="/assets/img/DKT 기본/image-20210527084504864.png" alt="" /></p>

<p>Transformer + 연속형, 범주형 조합의 input의 경우, embedding layer의 설정에 따라 input size가 다르다.</p>

<p><img src="/assets/img/DKT 기본/image-20210527090132348.png" alt="" /></p>

<p>범주형은 연속형과 다르게 인코딩을 통해 vector를 뽑아내야 한다.</p>

<p>Embedding은 일종의 Lookup Table을 만드는 것으로, 이 Lookup Table 또한 학습을 통해 결정된다.</p>

<p>이런식으로 Embedding된 값들은 concat되어 hidden_size를 만든다.</p>

<p>이때 concat되는 feature들의 차원이 Linear를 통해 hidden size에 맞게 줄어든다.</p>

<p><img src="/assets/img/DKT 기본/image-20210526004406142.png" alt="" /></p>

<p>DKT의 경우, Transformer구조를 활용 시 보통, 사용자 단위로 Sequence를 생성한 뒤, 각각 train input으로 넣어준다.</p>

<p>DKT의 경우 마지막 문제의 정답여부를 맞추는 Task 이므로 보통 Padding을 앞에 추가하여 뒷부분을 맞춘다.</p>

<p><img src="/assets/img/DKT 기본/image-20210526004317812.png" alt="" /></p>

<h2 id='Sequence-Data-문제-정의에-맞는-Transformer-Architecture-설계'>Sequence Data 문제 정의에 맞는 Transformer Architecture 설계</h2>

<p>Transformer 구조는 다양한 Sequence 데이터에서 강점을 보이지만, 많은 양의 데이터와 연산량을 요구하며, 종종 상황에 맞게 변형해서 사용하거나, 아예 다른 모델을 사용해야 하는 경우도 있다.</p>

<p>inductive bias : 특정 목적에 맞게 설계된 모델들(CNN, RNN)의 경우 input의 형태에 따라 bias가 생긴다, 즉, 적절하지 못한 input의 경우 성능이 나쁘다.(CNN에 Sequential input을 넣어준다던가)</p>

<p>Transfomer의 경우, inductive bias가 존재하지 않지만, 그만큼 데이터가 많이 필요하다.</p>

<p>이러한 Transformer를 개조하기 위해 Trasformer architecture의 변형을 알아보자.</p>

<h3 id='Data-Science-Bowl'>Data Science Bowl</h3>

<p>3~5세 들의 기초수학 학습을 위해 개념을 정확히 배웠는 지 맞추는 것이 대회의 목표</p>

<p>과거 데이터를 바탕으로 앞으로 어떻게 풀지 class 4(바로 맞춤, 한번 틀리고 맞춤, 여러번 틀리고맞춤, 못맞춤)개를 통해 예측</p>

<p><img src="/assets/img/DKT 기본/image-20210527092718159.png" alt="" /></p>

<p>학습 진행 시간, 학습 종류(영상물, 게임, 활동, 평가 등), 게임플레이 세계관과 사용 정보 등이 기록되어 주어진다.</p>

<p><img src="/assets/img/DKT 기본/image-20210527092745176.png" alt="" /></p>

<p>이 때, Transformer 구조가 널리 사용되지 않던 시절이였고, 자원과 데이터양이 한정되어있었지만, 한 유저가 Transformer-Encoder 모델인 BERT로 3위를 차지 하였으며,</p>

<ul>
  <li>서로 다른 범주형/연속형 데이터들을 어떻게 임베딩 했는가,</li>
  <li>BERT를 어떻게 활용했는가</li>
</ul>

<p>가 주안점이였다.</p>

<p><img src="/assets/img/DKT 기본/image-20210527093510990.png" alt="" /></p>

<p>서로 다른 범주형/연속형 Emedding은 다음과 같은 방법을 통하여 임베딩 했으며,</p>

<p><img src="/assets/img/DKT 기본/image-20210527093901162.png" alt="" /></p>

<p>위와 같이 Transformer 구조를 깊게 쌓아 마지막 Transformer 구조의 output 값을 softmax하여 classification 한다.</p>

<p>이때 마지막 layer 부분 마지막 Trnasformer를 제외한 연하게 칠해진 Transfomer 구조의 output은 사용되지 않으며 Loss에 의해 Backpropagation에 업데이트 되지 않는다.</p>

<h3 id='Riid'>Riid!</h3>

<p>토익 시험에 대비하여 공부한 학생들의 학습 과정을 모아둔 데이터로, 최종적으로 한 학생이 마지막에 푼 문항을 맞출지 틀리지 맞추는 대회이며, i-Scream 데이터와 매우 흡사하다.<br />
다만 데이터셋이 아주 많으며, 강의를 보는 interaction 데이터와 단순히 답을 맞췄는가 아닌가가 아닌, 사용자가 어떤 답을 냈는가와 오답 정리를 했는지도 포함되어 있음.</p>

<p>이때, 너무 데이터가 많아서, 임베딩된 2개의 Sequence를 하나로 이어 붙인 후, Sequence의 길이를 반으로 줄이는 대신, 하나의 임베딩 차원을 2배로 늘려 학습시켜 시간 복잡도를 줄임</p>

<p><img src="/assets/img/DKT 기본/image-20210527100842708.png" alt="" /></p>

<p><img src="/assets/img/DKT 기본/image-20210527100910150.png" alt="" /></p>

<h3 id='Predicting-Molecular-Properties'>Predicting Molecular Properties</h3>

<p>분자의 여러 정보들을 통해 원자 간 결합 상수를 찾는 대회</p>

<p>분자내 원자 간 결합 정보, 원자 간 가림막 효과, 분자의 에너지 상태, 분자 내 원자의 전하 상태, 결합 상수 세부 정보 등이 데이터로 주어짐</p>

<p>LGBM이나 Grpah NN을 통해 접근한 팀도 많음</p>

<p><img src="/assets/img/DKT 기본/image-20210527102510665.png" alt="" /></p>

<p>분자 별로 가능한 원자 조합들에 대해 모든 scalar_coupling_constant를 구해야 하므로, 위치가 중요하지 않은 Sequence Data로 볼 수 있으며, 한 분자를 Total Sequence, 원자 쌍의 하나의 Sequence로 본다면, 위 그림 처럼 원자 쌍 순서는 다르지만 결과가 똑같이 나와야함</p>

<p>Sequence 안에서 모든 token이 다른 모든 token을 참조하며, Positional Embedding을 통해 위치정보를 반영하는 방식인 Transformer 구조가 적절하다.</p>

<ul>
  <li>즉, 위치 관계가 상관없으므로 Positional Embedding을 안주면 됨 (Permutation Invariant Transformer)</li>
</ul>

<p><img src="/assets/img/DKT 기본/image-20210527103124039.png" alt="" /></p>

<p><img src="/assets/img/DKT 기본/image-20210527103428799.png" alt="" /></p>

<p>이때, 분자 별로 원자쌍이 135개 이므로 Sequence Length는 총 135개 SC(Scaling constant)이며,</p>

<p>두 원자의 정보들과 둘 사이의 관계정보 까지 임베딩 하여, 각 원자의 전하, 위치, 원자 번호, 원자 사이의 거리, 원자 결합 종류가 embedding된 vector를 input으로 사용</p>

<p><img src="/assets/img/DKT 기본/image-20210527103323178.png" alt="" /></p>

<p>최종적으로 예측해야하는 scaling constant(SC)가 Fc, sd, pso, dso의 합으로 이루어 져있으므로, SC를 예측하는 Transformer와 Fc, sd, pso, dso를 각각 에측하는 두 종류의 결과의 평균을 통하여 예측으로 제출</p>

<h3 id='Mechanisms-of-Actions-MoA'>Mechanisms of Actions (MoA)</h3>

<p>약물 투여시, 어떤 화학 반응이 일어나는지 예측하는 대회로, 투여한 약물의 종류, 양, 시간, 약물 합성방식, 투여 받은 사람의 유전자 발현 종류(772 features), 세포 생존 능력(cell viability) 등의 데이터를 제공함.</p>

<p>Sequence로 묶을 수 있는 데이터가 없고, Feature 수가 너무 많고, 예측 해야할 class의 수가 207개 임에 비해, 데이터는 2만 3천개 밖에 존재하지 않아, Transformer 구조가 잘 작동하지 않았다고 함.</p>

<p><img src="/assets/img/DKT 기본/image-20210527104229910.png" alt="" /></p>

<p>이를 위해 위 그림과 같은 CNN 모델을 사용했다.</p>

<ol>
  <li>다수의 Feature를 가진 유전 정보와 세포 생존 정보를 PCA(Principal component analysis)를 통해 50차원, 15차원의 벡터로 만듦</li>
  <li>기존의 feature와 concatenate하여 추가적인 feature로 생성</li>
  <li>위 결과를 Linear에 통과시켜 더 큰 차원의 1차원 벡터로 변환,
    <ul>
      <li>Linear feature ordering을 통하여 차원을 늘려주어, 활용가능한 충분한 Pixel의 양을 생성,</li>
      <li>생성된 데이터 안에서 feature를 최적의 정렬을 학습하는 효과</li>
      <li>각 벡터의 원소가 가지는 의미를 동일하게 만듦</li>
    </ul>
  </li>
  <li>이를 짧은 길이의 여러 채널을 가지는 1D 데이터로 변환</li>
  <li>이 데이터를 Conv1D Architecture에 통과시켜 최종결과 생성
    <ul>
      <li>이때, 커널 사이즈는 n X embedding size 인경우가 많다. (뒷 부분이 embedding size가 아니면 한 feature의 일부 embedding 만 가져가므로)</li>
    </ul>
  </li>
</ol>

<p>위 성능이 단일 모델 기준으로 가장 성능이 좋았다.</p>

<h2 id='Kaggle-Riiid-Competition-Winner’s-Solution-탐색'>Kaggle Riiid Competition Winner’s Solution 탐색</h2>

<h3 id='Feature-Engineering'>Feature Engineering</h3>

<h4 id='공통적인-FE'>공통적인 FE</h4>

<p>Feature Engineering의 접근 방법에는 2가지가 있다.</p>

<ol>
  <li><strong>Bottom-Up</strong></li>
</ol>

<p>Data 기반 방식,</p>

<p>1) EDA를 통해 특징을 살피고,</p>

<p>2) 해당 특징을 Test Data를 통해 검증 뒤,</p>

<p>3) 이를 통해 새로운 feature를 만들어 내고, CV(Cross Validation) 상승을 확인</p>

<ul>
  <li>Time, group에 따른 K-fold Validation을 시행해보고, 오르지 않을때 까지(틀리지 않을때 까지) 시도.</li>
</ul>

<p>4) model 생성한 후, hyperparameter를 찾는 방식</p>

<p>예를 들어, 정규분포와 일부 다른 지점을 찾아, 해당 부분은 feature로 생성</p>

<ol>
  <li><strong>Top-Down</strong></li>
</ol>

<p>가설(Hypothesis), domain 지식 기반 컨설팅 방법론(Logical thinking)</p>

<p>가설-구현-검증으로 이루어져 있으며,</p>

<p>Feature Extraction 시,</p>

<p>1) 데이터에 대한 질문 &amp; 가설</p>

<p>2) 데이터를 시각화하고, 변환하고, 모델링하여 가설에 대한 답을 탐색(구현-성능평가)</p>

<p>3) 찾는 과정에서 배운 것들을 토대로, 다시 가설을 다듬고 또 다른 가설 생성</p>

<p>위 두 방식을 같이 사용하는것이 Best,</p>

<p><img src="/assets/img/DKT 기본/image-20210531223104376.png" alt="" /></p>

<p>이후, 정형 데이터의 경우, Feature의 Numerical, Categorical 종류를 구분한 후, 각 종류의 특징에 따른 EDA를 해본다.</p>

<p>예를 들어, 숫자형의 경우, 평균, 범위, 첨도 등을 알아보며,</p>

<p>범주형의 경우, Missing value, value 별 Count, percent 최빈도 값 등을 알아보자.</p>

<p>Target과의 상관관계를  Bar plot, hsit plot 등을 그려 알아볼 수 있다.</p>

<h4 id='Riiid의-경우'>Riiid의 경우</h4>

<p>1) 문항을 푸는 패턴으로..</p>

<p>이전에 푼 문제인가?, 혹시 정답을 한 번호로 찍었는가?를 알 수 있다.</p>

<p>아쉽게도 i-Scream 데이터는 선택지에 대한 정보가 없음.</p>

<p>2) 사용자가 문항을 푸는 데 걸린 평균 시간으로…</p>

<p>오래 걸렸을 경우, 맞춘 학생의 평균 시간과 틀린 학생의 평균 시간을 Feature로 주어 활용할 수 있다.</p>

<p>3) 사용자 정답률 추이로…</p>

<p>최근 정답률로, 앞으로 문항들의 정답 여부를 구할 수 있다.</p>

<ul>
  <li>최근 정답률이 낮아지면,  현재 푸는 문항들은 잘 모른다는 의미이므로, 마찬가지로 줄어들 것이다.</li>
</ul>

<p>4) 이미 푼 문제가 다시 등장하는 경우…</p>

<p>맞췄거나, 틀렸어도 다시 복습했을 확률이 있으므로, 정답률이 올라갈 수 있음.</p>

<p>5) 문항, 시험지, 태그의 평균 정답률로 …</p>

<p>쉬운 문항, 시험지, 태그의 경우 정답률이 올라갈 수 있다.</p>

<p>또한, 사용자가 푸는 문제에 대한 정보(문항의 정답률, 문항이 가진 태그의 정답률)가 많을 수록 활용 하기 쉽다.</p>

<ul>
  <li>
    <p>문항-태그 정보 에서 content2vec,</p>
  </li>
  <li>사용자-문항 정보로 SVD, LDA, item2vec</li>
  <li>문항을 특징화하는 IRT, ELO</li>
</ul>

<p>등의 implicit 한 정보를 활용할 수 있다.</p>

<p><strong>Data Leakage</strong></p>

<p>Feature를 넣어서 결과가 좋게 나오면 적용해도 되는 것일까?</p>

<p>해당 문항의 평균 정답률 Feature를 생각해보자.</p>

<p>평균 정답률은 validation이나, test dataset을 제외하고, 계산하게 된다.</p>

<p>즉, 전체 데이터셋의 정답률은 실제 정답률과 다를 수 도 있다.</p>

<p>과거 현업에서는 예를 들어, 5월 1일 ~ 8일 데이터는 train dataset, 8일부터 ~10일 데이터는  validation set, 11일 부터 15일 까지는 test dataset으로 주는 등, 시간을 고려하지 않고 주어 올바르지 못한 결과를 주는 경우가 많았다. (Inductive bias 문제?)</p>

<p>하지만 최근에는 time series api를 이용해, inference 시, 한 row가 진행될 때마다, update하므로 문제가 없다.</p>

<p><strong>다양한 방법을 통한 문항 공유의 Feature 뽑아내기</strong></p>

<p>추천 시스템에서 많이 사용되는 Matrix Factorization 방식으로 사용자의 벡터와 문항의 벡터를 만들 수 있음. (최근에는 Factorization Machine을 많이 사용함.)</p>

<p><img src="/assets/img/DKT 기본/image-20210531232231451.png" alt="" /></p>

<p>Riid, i-Scream 데이터의 경우, 문제를 푼 사용자와 사용자가 푼 문항을 통해 user-item 행렬을 만들어 진행 가능.</p>

<p>혹은 유사한 방법으로 선형대수학에서 Singular Value Decomposition (SVD)를 활용할 수 있음.</p>

<p><img src="/assets/img/DKT 기본/image-20210531232753395.png" alt="" /></p>

<p>난이도의 이론인 ELO, IRT(Item Response Theory) 또한 활용 가능하다.</p>

<p>이는 학생과 문항 별로 고유한 특성이 있다는 가정을 하는 이론이다.</p>

<ul>
  <li>
    <p>학생은 잠재능력이 있고, 각 문항은 학생의 잠재 능력을 받아 문항을 맞출 확률을 반환하는 고유 함수를 가지고 있다고 가정.</p>
  </li>
  <li>
    <p>만약 학생의 잠재능력과 문항 별 모수를 안다면, 전체 학생의 모든 문제를 맞출 확률을 모두 알 수 있다는 이론.</p>
  </li>
</ul>

<p><img src="/assets/img/DKT 기본/image-20210531233505602.png" alt="" /></p>

<p>이때, 문항이 가진 고유 함수는 다음과 같이 정의됨.<br />
\(\phi(\theta;\beta)=c+\frac{1-c}{1+e^{-(\theta-\beta)}}\\
\phi : 학생의\ 고유\ 능력,\ \beta:\ 문항\ 별\ 함수의\ 모수,\\
c:\ 무작위로\ 찍을\ 시\ 맞출\ 확률(사지선다\ 시, 0.25)\)<br />
IRT(Item Response Theory)에서는 여기에 더 많은 가정을 넣어 문항 별 함수를 다양하게 만들 수 있음.</p>

<p>Riiid 에서는 간단하게 $\theta$와 $\beta$를 간단하게 추정하는 방법을 사용할 수도 있다.</p>

<ol>
  <li>전체 학생의 $\theta$와 전체 문항의 $\beta$를 0으로 초기화한다.</li>
  <li>아래 수식에 맞춰서 $\theta$와 $\beta$를 업데이터, (correct는 0/1의 binary 정답 여부)</li>
</ol>

\[\theta_{n+1}\leftarrow \theta_n + \eta_{\theta_n}*(correct-\phi(\theta_n;\beta_n))\\
\beta_{n+1}\leftarrow \beta_n + \eta_{\beta_n}*(correct-\phi(\theta_n;\beta_n))\]

<ol>
  <li>이 과정을 전체 데이터에 대해 반복해 최종값을 찾음</li>
  <li>구한 이 값들을 통해 test 데이터 내의 학생 별 문항에 대한 정답률을 구함.</li>
</ol>

<p><strong>Continuous Embedding</strong></p>

<p><img src="/assets/img/DKT 기본/image-20210531234346076.png" alt="" /></p>

<p>일반적으로 연속형 데이터는 임베딩 데이터와 달리 Embedding 하지 않고 집어넣는다.</p>

<p>범주형 데이터의 경우, 임베딩 행렬의 한 열을 사용하는 형태이며, 연속형은 그럴 수 없으므로,  임베딩 대신, 주어진 연속형 데이터 값에 가중을 더 두고, 그 주변 값들에 더 작은 가중을 주어, 이 임베딩 행렬의 특정 열들을 가중합한 벡터를 임베딩으로 사용함.</p>

<p>예를 들어 1~100까지 임베딩 해 놓은뒤, 50을 임베딩하려 할때, (50의 임베딩값*0.45) + (49의 임베딩값*0.18)+ (51의 임베딩값*0.18)+(48의 임베딩값*0.09)+(52의 임베딩값*0.9) …대략적인 정규분포를 통하여 사용한다.</p>

<h3 id='Last-Query-Transformer-RNN'>Last Query Transformer RNN</h3>

<p>일반적으로,</p>

<ol>
  <li>LGBM, DNN 같은 Machine Learing의 경우,
    <ul>
      <li>많은 Feature Engineering을 통해, 다량의 Feature를 필요로 하고, 유의미한 것을 찾아내야 한다.</li>
    </ul>
  </li>
  <li>Transformer 같은 Deep Learning의 경우,
    <ul>
      <li>알아서 Feature를 찾아주므로, FE를 적게 사용하고 아주 많은 양의 데이터를 요구로 하고, sequence의 길이의 제곱에 비례한 시간 복잡도를 가지므로 부담스럽다.</li>
      <li>Tabular data(정형 데이터)에서는 여전히 FE가 많이 필요, 보통의 경우에도 FE를 통해 성능을 올릴 수 있음.</li>
    </ul>
  </li>
</ol>

<p><strong>Resolving deficits</strong></p>

<p><img src="/assets/img/DKT 기본/image-20210531235630477.png" alt="" /></p>

<p>Riid의 1등 솔루션인 Last Query Transformer RNN은, 위 두 가지 문제를 모두 해결한 방법으로 1등을 차지.</p>

<p>특징으로,</p>

<ol>
  <li>
    <p>다수의 Feature를 사용하지 않음, 대신 sequence 길이를 늘림(시간 복잡도가 증가하는 문제를 아래로 해결).</p>

    <ul>
      <li>5개의 feature 만 사용, 다른 상위권 모델의 경우 70~80개 사용</li>
    </ul>
  </li>
  <li>
    <p>마지막 Query만 사용하여 시간 복잡도를 낮춤</p>

    <p><img src="/assets/img/DKT 기본/image-20210601010907195.png" alt="" /></p>

    <ul>
      <li>일반적으로 $n \times m$ 행렬과  $m \times l$ 행렬의 곱에 대한 시간 복잡도는 $O(nml)$이다.</li>
      <li>Transformer에서 Query, Key, Value에 대한 행렬 Q, K, V가 각각 (L, d)로 주어져 있고, 우리가 계산하는 Attention Score의 계산식은 다음과 같다.</li>
    </ul>

\[Att(Q, K, V) = \mathcal{softmax}\frac{QK^T}{\sqrt{d}}*V\\
Scaled\ dot\ attention : 유사도\ 구할시\ dot\ 연산\ 활용\]

    <ul>
      <li>시간 복잡도가 $O(L^2d)$로 변한다.</li>
      <li>추가적으로 마지막 Query만 사용한다면, Q 행렬의 차원이 (L, d)에서 (1, d)로 줄어든다.</li>
      <li>즉, 최종적으로 $O(Ld)$로 줄어든다.</li>
    </ul>

    <p><img src="/assets/img/DKT 기본/image-20210601011046485.png" alt="" /></p>
  </li>
  <li>
    <p>문제 간 특징을 Transformer로 파악하고, 일련의 Sequece 사이 특징들을 LSTM을 활용해 뽑아낸 뒤, 마지막 DNN을 통해 Sequence 별 정답을 예측</p>
  </li>
</ol>

<ul>
  <li>Positional embedding과 look-ahead mask를 제외하여 순서와 관계없이 입력 간의 관계를 파악하게 함</li>
  <li>그 뒤, Sequential 특성 파악을 위해 LSTM 활용</li>
  <li>이를 통해, Encoder 수(=Layer 수)와 Sequence length를 증가시켜 성능이 향상 됨.</li>
  <li>BERT 모델에 비해 3배 이상의 sequence length를 가짐(512 vs 1728)</li>
</ul>

<h2 id='ML-Pipeline'>ML Pipeline</h2>

<p>[DKT-8]ML_Pipeline.ipynb 참조</p>

<h2 id='Model-Serving'>Model Serving</h2>

<h3 id='모델-서빙의-종류'>모델 서빙의 종류</h3>

<p><strong>On-device Serving</strong></p>

<p><strong>Cloud-based Serving</strong></p>

<h3 id='웹서버를-활용한-모델-서빙'>웹서버를 활용한 모델 서빙</h3>

<h4 id='HTTP-통신'>HTTP 통신</h4>

<h4 id='웹-서버-구축'>웹 서버 구축</h4>

<h3 id='MLflow를-활용한-모델-서빙'>MLflow를 활용한 모델 서빙</h3>

<p><img src="/assets/img/DKT 기본/image-20210607225750620.png" alt="" /></p>

<h4 id='MLflow'>MLflow</h4>

<h4 id='예시-시스템'>예시 시스템</h4>

<h2 id='End-to-End-Project'>End to End Project</h2>

<h3 id='실제-현업과-Competition의-비교'>실제 현업과 Competition의 비교</h3>

<p><img src="/assets/img/DKT 기본/image-20210611212230709.png" alt="" /></p>

<p><img src="/assets/img/DKT 기본/image-20210611212400505.png" alt="" /></p>

<h3 id='문제정의-3요소'>문제정의 3요소</h3>

<p><strong>input(Data_X, DataType)</strong></p>

<p><strong>Output(Data_Y, 예측해야 할 값)</strong></p>

<p><strong>Metric(평가 지표)</strong></p>

<h3 id='Workflow'>Workflow</h3>

<p><strong>Workflow란?</strong></p>

<p><img src="/assets/img/DKT 기본/image-20210611233524730.png" alt="" /></p>

<h4 id='워크-플로우-관리'>워크 플로우 관리</h4>

<p><strong>Apache Airflow를 활용한 워크 플로우 관리</strong></p>

<p><img src="/assets/img/DKT 기본/image-20210611233443912.png" alt="" /></p>

<p>Airflow는 Workflow를 프로그래밍 방식으로 작성, 예약 및 모니터링하는 플랫폼으로, python을이용 한 워크 플로우 관리 툴이다.</p>

<ul>
  <li>Airbnb -&gt; Apache 로 프로젝트 넘어감</li>
</ul>

<p>Airflow는 크게</p>

<p>Webserver, Scheduler, Worker, Meta DB로 이루어져 있다.</p>

<p><strong>토이 프로젝트 소개</strong></p>


</div>

  </div><a class="u-url" href="/articles/AI/Structured_Data/DKT%20%EA%B8%B0%EB%B3%B8.html" hidden></a>
  <p class="u-path" hidden>_articles/AI/Structured_Data/DKT 기본.md</p>
  <script type="module" src="/assets/scripts/utils/update_recents.js"></script>
</article>

    </div>
  </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">The Digital garden of Nurgle.</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="a-name">The Digital garden of Nurgle.</li><li><a class="u-email" href="mailto:roadvirushn@gmail.com">roadvirushn@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li>
    <a href="https://github.com/RoadVirusHN"><svg class="svg-icon">
        <use xlink:href="/assets/svg/social-icons.svg#github"></use>
      </svg>
      <span class="username">RoadVirusHN</span></a>
  </li><!---->
</ul></div>

      <div class="footer-col footer-col-3">
        <p>이것이 디지털 동물의 숲이다!! 파멸편 (This is the Digital Animal Crossing!! Bad Ending.01)</p>
      </div>
    </div>

  </div>

</footer>
</body>

<script src="/assets/scripts/bundle/common.bundle.js"></script>

</html>