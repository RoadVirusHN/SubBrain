<!DOCTYPE html>
<html lang="kr"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>OS 정리-Chap 9-입출력 시스템과 디스크 관리 | 🧠SUBBRAIN</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="OS 정리-Chap 9-입출력 시스템과 디스크 관리" />
<meta property="og:locale" content="kr" />
<meta name="description" content="style: number min_depth: 2 max_depth: 3 varied_style: true" />
<meta property="og:description" content="style: number min_depth: 2 max_depth: 3 varied_style: true" />
<link rel="canonical" href="http://localhost:4000/articles/computer_science/OS/IT_COOK_BOOK_OS_%EC%A0%95%EB%A6%AC/OS%20%EC%A0%95%EB%A6%AC-Chap%209-%EC%9E%85%EC%B6%9C%EB%A0%A5%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC%20%EB%94%94%EC%8A%A4%ED%81%AC%20%EA%B4%80%EB%A6%AC.html" />
<meta property="og:url" content="http://localhost:4000/articles/computer_science/OS/IT_COOK_BOOK_OS_%EC%A0%95%EB%A6%AC/OS%20%EC%A0%95%EB%A6%AC-Chap%209-%EC%9E%85%EC%B6%9C%EB%A0%A5%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC%20%EB%94%94%EC%8A%A4%ED%81%AC%20%EA%B4%80%EB%A6%AC.html" />
<meta property="og:site_name" content="🧠SUBBRAIN" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-10T23:23:16+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="OS 정리-Chap 9-입출력 시스템과 디스크 관리" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-10T23:23:16+09:00","datePublished":"2022-08-10T23:23:16+09:00","description":"style: number min_depth: 2 max_depth: 3 varied_style: true","headline":"OS 정리-Chap 9-입출력 시스템과 디스크 관리","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/articles/computer_science/OS/IT_COOK_BOOK_OS_%EC%A0%95%EB%A6%AC/OS%20%EC%A0%95%EB%A6%AC-Chap%209-%EC%9E%85%EC%B6%9C%EB%A0%A5%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC%20%EB%94%94%EC%8A%A4%ED%81%AC%20%EA%B4%80%EB%A6%AC.html"},"url":"http://localhost:4000/articles/computer_science/OS/IT_COOK_BOOK_OS_%EC%A0%95%EB%A6%AC/OS%20%EC%A0%95%EB%A6%AC-Chap%209-%EC%9E%85%EC%B6%9C%EB%A0%A5%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC%20%EB%94%94%EC%8A%A4%ED%81%AC%20%EA%B4%80%EB%A6%AC.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="🧠SUBBRAIN" /><link rel="icon" type="image/x-icon" href="/assets/img/common/favicon.ico">
</head>
<div class="scrollWrapper">
  <div class="scrollbar"></div>
  <div class="progressbar"></div>
  <div class="scrollbarButton"></div>
</div>

<link rel="stylesheet" href="/assets/css/obsidian/obs-scrollbar.css" />

<!--<div class="redirection">
  <h1 class="name">Redirection for full experience.</h1>
  <br>
  Move to <br /> <a class="to" href="#">netlify url</a><br />
  <div>after <span class="counter">10</span>secs.</div>
  press <button class="cancle">here</button> to cancle.
</div>
<div class="overlay"></div>
<script type="module" src="/assets/scripts/common/components/init_redirection.js"></script>

<link rel="stylesheet" href="/assets/css/common/redirection.css" />-->

<body><header class="site-header" role="banner">

  <div class="wrapper" style="display: flex; justify-content: space-between;"><div id="header-wrapper">
    <a class="site-title" rel="author" href="/blog">🧠SUBBRAIN</a>

    </div><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><script src="https://unpkg.com/lunr/lunr.js"></script>
<link rel="stylesheet" href="/assets/css/common/searchbar.css" />

<form id="search-form" method="get">
  <span id="search-wrapper">
    <span id="tag-holder" ></span>
    <input type="text" id="search-box" placeholder='Prefix "#" to add Tag.' autocomplete="off">
    <span class="inner-search" >🔍</span>
  </span>
</form><a class="page-link" href="/">ABOUT ME</a><a class="page-link" href="/blog">ALL ARTICLES</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
    <link rel="stylesheet" href="/assets/css/common/drawer.css" />
<button class="drawer-button open">▶️</button>
<div id="drawer" class="close">
  <button class="drawer-button close">
    ◀️
  </button>
  <div class="drawer-content">
    <div class="my-description">
      <div class="avatar-section" style="display: flex; flex-direction: row;">

        <img src="/assets/img/common/avatar.png" alt="avatar" class="avatar">
        <div style="display: flex; flex-direction: column; margin-left: 5px;">
          <a href="/about/">
            <h3 class="name">ROADVIRUSHN</h3>
          </a>
          <div class="stack-list" style="margin: 5px 0 0 5px;">
            <a title="My github page" href="https://github.com/RoadVirusHN">
  <svg class="svg-icon" width="16" height="16" viewBox="0 0 16 16">
    <use xlink:href="/assets/svg/social-icons.svg#github"></use>
  </svg>
</a>
<a title="My G-mail" href="mailto:roadvirushn@gmail.com">
  <svg class="svg-icon" width="16" height="16" viewBox="0 0 16 16">
    <use xlink:href="/assets/svg/social-icons.svg#gmail"></use>
  </svg>
</a>
<a title="My Blog" href="https://luminous-bubblegum-8e9be4.netlify.app">
  <svg class="svg-icon" width="16" height="16" viewBox="0 0 16 16">
    <use xlink:href="/assets/svg/social-icons.svg#blog"></use>
  </svg>
</a>
          </div>
        </div>
        <!-- <h4 class="name">(JUNSEOK YUN)</h4> -->
      </div>
      <p style="margin: 5px 0 0 0;">
        풀스택 웹🌐 개발자 지망생 🧑🏽‍💻
        <br>
        ➕ 인공지능 관심 🤖
      </p>
    </div>
      <hr>
      <div class="categories">
        <h3 style="margin: 0;"><a href="/">Categories</a></h3>
        <ul class="category-list">
  
  
  
  <li>
    <strong style="font-size: larger;">┣ </strong>
    <h3 style="display: inline;">
      
      <a href="/categories/COMPUTER_SCIENCE/" class="category-drop-down">▶</a>
      
      <span class="category-link">COMPUTER_SCIENCE</span>
    </h3>
    <span style="font-size: xx-small;">
       
      📂: 6
    </span>
    <ul class="child-category-list">
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/DATABASE/">DATABASE</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/ALGORITHM/">ALGORITHM</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 16 
            📂: 1
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/OS/">OS</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            📂: 1
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/NETWORK/">NETWORK</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 8 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/ETC/">ETC</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            📂: 1
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┗ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/COMPUTER_SCIENCE/OSSU/">OSSU</a>
        </h4>
          <span style="font-size: xx-small;">
             
            📂: 1
          </span>
      </li>
      
    </ul>
  </li>
  
  
  <li>
    <strong style="font-size: larger;">┣ </strong>
    <h3 style="display: inline;">
      
      <a href="/categories/WEB/" class="category-drop-down">▶</a>
      
      <span class="category-link">WEB</span>
    </h3>
    <span style="font-size: xx-small;">
       
      📂: 3
    </span>
    <ul class="child-category-list">
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/WEB/FRONTEND/">FRONTEND</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/WEB/BACKEND/">BACKEND</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            📂: 2
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┗ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/WEB/CI,CD/">CI,CD</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            📂: 2
          </span>
      </li>
      
    </ul>
  </li>
  
  
  <li>
    <strong style="font-size: larger;">┣ </strong>
    <h3 style="display: inline;">
      
      <a href="/categories/ETC/" class="category-drop-down">▶</a>
      
      <span class="category-link">ETC</span>
    </h3>
    <span style="font-size: xx-small;">
       
      📂: 2
    </span>
    <ul class="child-category-list">
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/ETC/ETCS/">ETCS</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 8 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          ┃  
          ┗ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/ETC/SUBBRAIN 개발기/">SUBBRAIN 개발기</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 5 
            
          </span>
      </li>
      
    </ul>
  </li>
  
  
  <li>
    <strong style="font-size: larger;">┗ </strong>
    <h3 style="display: inline;">
      
      <a href="/categories/AI/" class="category-drop-down">▶</a>
      
      <span class="category-link">AI</span>
    </h3>
    <span style="font-size: xx-small;">
       
      📂: 9
    </span>
    <ul class="child-category-list">
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/AITOOLS/">AITOOLS</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 3 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/CV/">CV</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/DEEP_LEARNING/">DEEP_LEARNING</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/DATA_VIS/">DATA_VIS</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/GRAPH/">GRAPH</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/LIGHTWEIGHT/">LIGHTWEIGHT</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/MATH/">MATH</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 1 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┣ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/NLP/">NLP</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 3 
            
          </span>
      </li>
      
      <li>
        <strong style="font-size: larger;">
          &nbsp;&nbsp;&nbsp;
          ┗ 
        </strong>
        <h4 style="display: inline; background-color: lightgray; padding: 0px 1px; border-radius: 2px;">
          <a class="category-link" href="/categories/AI/STRUCTURED_DATA/">STRUCTURED_DATA</a>
        </h4>
          <span style="font-size: xx-small;">
            📄: 2 
            
          </span>
      </li>
      
    </ul>
  </li>
  
</ul>
      </div>
      <hr>
      <div class="recent-view">
        <h3 style="margin: 0;">Recent views</h3>
        <ul style="margin: 0;">
          <li>
            <strong style="color:rgb(219, 219, 12);">1 <a id="recent-1"></a></strong>
          </li>
          <li>
            2 <a id="recent-2"></a>
          </li>
          <li>
            3 <a id="recent-3"></a>
          </li>
          <li>
            4 <a id="recent-4"></a>
          </li>
          <li>
            5 <a id="recent-5" style="overflow: hidden;"></a>
          </li>
        </ul>
      </div>
    </div>
    <hr>
  <div style="height: 7vh;"></div>
</div>
    <div class="wrapper">
      <article class="article h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="article-header">
    <h1 class="article-title a-name" itemprop="name headline">OS 정리-Chap 9-입출력 시스템과 디스크 관리</h1>
    <p class="article-meta">
      <time class="dt-published" datetime="2022-08-10T23:23:16+09:00" itemprop="datePublished">Aug 10, 2022
      </time></p>
  </header>

  <div class="article-content e-content" itemprop="articleBody">
     
  
<script>
  MathJax = {
    tex: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"],
      ],
    },
    svg: {
      fontCache: "global",  
     // scale: 1.5,
    },
    chtml: {
     // scale: 1.5,
    },
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>
 
 


<script src="/assets/scripts/bundle/obsidian.bundle.js"></script>
<link rel="stylesheet" href="/assets/css/obsidian/callout.css" />
<link rel="stylesheet" href="/assets/css/obsidian/image.css" />
<link rel="stylesheet" href="/assets/css/obsidian/link-warning.css" />
<link rel="stylesheet" href="/assets/css/obsidian/preview.css" />

<div class="content-section">
  <html><head></head><body><ol id="markdown-toc-0"><li lvl="2"><a id="markdown-toc-0-0" href="#01-입출력-시스템-관리">01 입출력 시스템 관리</a><ul><li lvl="3"><a id="markdown-toc-0-1" href="#1-입출력-시스템과-입출력-모듈">1 입출력 시스템과 입출력 모듈</a><ul></ul></li><li lvl="3"><a id="markdown-toc-0-2" href="#2-입출력-모듈의-구성">2 입출력 모듈의 구성</a><ul></ul></li><li lvl="3"><a id="markdown-toc-0-3" href="#3-입출력-모듈의-기능">3 입출력 모듈의 기능</a><ul></ul></li><li lvl="3"><a id="markdown-toc-0-4" href="#4-프로세서-역할에-따른-입출력-방법">4 프로세서 역할에 따른 입출력 방법</a><ul></ul></li><li lvl="3"><a id="markdown-toc-0-5" href="#5-커널-입출력-서브시스템">5 커널 입출력 서브시스템</a><ul></ul></li></ul></li><li lvl="2"><a id="markdown-toc-0-6" href="#02-디스크의-구조와-스케줄링">02 디스크의 구조와 스케줄링</a><ul><li lvl="3"><a id="markdown-toc-0-7" href="#1-디스크의-구조">1 디스크의 구조</a><ul></ul></li><li lvl="3"><a id="markdown-toc-0-8" href="#2-디스크-액세스-시간">2 디스크 액세스 시간</a><ul></ul></li><li lvl="3"><a id="markdown-toc-0-9" href="#3-디스크-스케줄링의-개념과-종류">3 디스크 스케줄링의 개념과 종류</a><ul></ul></li><li lvl="3"><a id="markdown-toc-0-10" href="#탐색-시간-최적화">탐색 시간 최적화</a><ul></ul></li><li lvl="3"><a id="markdown-toc-0-11" href="#회전-지연시간-최적화">회전 지연시간 최적화</a><ul></ul></li><li lvl="3"><a id="markdown-toc-0-12" href="#12-디스크-스케줄링-알고리즘의-선택">12 디스크 스케줄링 알고리즘의 선택</a><ul></ul></li></ul></li><li lvl="2"><a id="markdown-toc-0-13" href="#03-RAID">03 RAID</a><ul><li lvl="3"><a id="markdown-toc-0-14" href="#RAID의-소개">RAID의 소개</a><ul></ul></li><li lvl="3"><a id="markdown-toc-0-15" href="#2-RAID-계층">2 RAID 계층</a><ul></ul></li></ul></li></ol>
<h1 id="9-입출력-시스템">9. 입출력 시스템</h1>

<div class="callout callout-quote" id="callout-bce941a4-808e-4ecc-bfe0-f220aee23d69">
      <div class="header">
        <span class="emoji">🗣️</span>
        <span class="title"><strong>출처
</strong></span>
        <button class="collapse">🔼</button>
      </div>
      <div class="card" name="card">
    
    <div class="content" name="content">
<blockquote>
  <p><span class='link-warning'>
      <a href="https://www.hanbit.co.kr/store/books/look.php?p_code=B3239422381" class="wikilink externallink">IT COOK BOOK 운영체제 (개정 3판, 구현회 저, 한빛 아카데미)</a>
      <a class="link-title" href="#" stlye="display: none;"></a>
      <span class='link-warning-text' style="display: none;" >보안 확인 : <em>외부링크</em><br/><em>
      "https://www.hanbit.co.kr/store..."</em>로
        <button onclick="window.open('https://www.hanbit.co.kr/store/books/look.php?p_code=B3239422381','_blank'); return false;">이동</button>?
      </span>
    </span>를 정리한 내용입니다.</p>
</blockquote>

</div>
    </div>
    </div>
<h2 id="01-입출력-시스템-관리">01 입출력 시스템 관리</h2>
<h3 id="1-입출력-시스템과-입출력-모듈">1 입출력 시스템과 입출력 모듈</h3>
<p>입출력 시스템은 모니터, 키보드 같은 하드웨어인 입출력 장치와 입출력 모듈까지 포함한다.</p>
<ul>
  <li>입출력 장치 : 실제 사용자와 입출력 수행</li>
  <li>입출력 모듈 : 메모리나 프로세서, 레지스터 등 내부 저장장치와 물리적 입출력 장치 사이의 이진 정보를 전송
    <ul>
      <li>입출력 채널(I/O channel), 입출력 프로세서(I/O Processor) : 프로세서를 대신해 입출력과 관련된 복잡한 일 처리</li>
      <li>입출력 제어기(I/O Controller), 장치 제어기(device controller): 단순 프로세서의 입출려과 관련된 일을 담당</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-31-31-image.png" alt=""></p>

<p>그림 9-1처럼 주변 장치를 직접 시스템 버스에 연결 하지 않고 입출력 제어기로 연결한다.<br>
입출력 장치에 따라 입출력 속도, 제어 및 운용법이 다르기 때문이다.</p>

<p>주로 정보 단위(워드, 문자, 블록), 처리량 등을 동기화한다.</p>

<h3 id="2-입출력-모듈의-구성">2 입출력 모듈의 구성</h3>
<p>아래 그림은 일반적인 입출력 모듈의 구성이다.<br>
<img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-32-04-image.png" alt=""></p>

<ul>
  <li>데이터 레지스터 : 입출력 모듈로 출입하는 데이터를 일시적으로 저장</li>
  <li>제어 레지스터 : 상태 레지스터를 프로세서의 명령에 따라 동작</li>
  <li>상태 레지스터 : 현재의 상태 정보를 저장, 제어 레지스터에 의해 동작</li>
  <li>입출력 논리회로 : 상태 레지스터의 정보를 제어하는 장치의 주소로 인식하고 각 장치와 인터페이스를 제어</li>
  <li>제어 버스: 프로세서와 교신</li>
</ul>

<h3 id="3-입출력-모듈의-기능">3 입출력 모듈의 기능</h3>

<ul>
  <li><strong>내부 자원과 데이터 입출력 등의 다양한 동작 제어 및 타이밍</strong>
    <ul>
      <li>입출력 모듈이 외부 장치 타이밍, 데이터 형식, 기계적 동작 등을 처리하므로 프로세서는 단순히 파일 열기와 닫기로 장치를 제어할 수 있다.</li>
      <li>프로세서가 입출력 장치에 명령을 보내기 위해 입출력 장치의 식별자를 주소로 지정하는 방법 두 가지
        <ul>
          <li>전용 메모리 주소 공간에 주소 지정하는 전용 입출력 방법</li>
          <li>메인 메모리 주소 공간 일부를 입출력 주소 공간으로 공유하는 메모리 매핑 주소 방법, 유연성, 인터럽트 신호가 특징</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>프로세서에서 명령을 전달받고, 관련된 메시지를 인식</strong>
    <ul>
      <li>메시지 인식 순서
        <ol>
          <li>명령 해독 : 프로세서에서 명령들을 받아 해독한다.</li>
          <li>데이터 교환 : 데이터 버스로 프로세서와 데이터를 교환</li>
          <li>상태 보고 : 저속 주변장치의 상태를 확인하여 프로세서에 보고</li>
          <li>주소 인식 : 모듈에 연결된 여러 장치를 구분할 주소를 인식</li>
        </ol>
      </li>
    </ul>
  </li>
  <li><strong>버퍼링을 이용해 전송속도 조절</strong>
    <ul>
      <li>메인 메모리와 입출력 장치 간의 속도 간극을 해결하기 위해 버퍼를 이용해 데이터 전송</li>
    </ul>
  </li>
  <li><strong>오류 검출</strong>
    <ul>
      <li>종이걸림 같은 기계적 오류, 전송 오류 등의 검출을 위해 패리티 비트 같은 오류 검출 코드 사용</li>
    </ul>
  </li>
</ul>

<h3 id="4-프로세서-역할에-따른-입출력-방법">4 프로세서 역할에 따른 입출력 방법</h3>

<p>프로세서와 입출력 장치의 입출력 방법에 따라 다음과 같이 나눌 수 있다.</p>
<h4 id="4-1-프로그램-제어-입출력-방법">4.1 프로그램 제어 입출력 방법</h4>

<p>프로세서 내부의 입출력 데이터와 주소 레지스터를 입출력 모듈과 직접 연결, 전송하는 형태</p>

<p>프로세서가 입출력 장치의 상태 비트(status bit)를 주기적으로 확인하므로 폴링(polling) 방법이라고도 한다.</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-32-34-image.png" alt=""></p>

<p>입력 시, 워드 단위로 입출력 장치, 입출력 모듈을 거쳐 입출력 데이터 레지스터로 이동한 뒤, 프로세서의 산술 논리 연산 장치로 보내져 처리된다.</p>

<p>반대로 출력 시, 산술논리 연산장치의 결과를 입출력 데이터 레지스터로 이동하고 프로그램을 이용해 입출력 모듈로 전송한다.</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-32-51-image.png" alt=""></p>

<p>데이터 전송 시에는 장치의 포트 상태 레지스터에 저장되있는 입출력 장치의 상태 비트를 폴링 순환 (그림 9-4)을 통해 검사한다.</p>

<p>폴링 순환이 너무 잦으면 시간과 자원 낭비가 생기고, 너무 적으면 입출력 장치가 너무 오래 쉬게 된다.</p>

<p>+ 하드웨어가 적게 필요<br>
+ 입출력 장치가 직접 메모리에 접근하지 않음. 보안상 유리</p>

<p>- 프로세서가 데이터 입출력에 관여하므로 프로세스 부담이 큼<br>
- 데이터 처리속도 느림, 프로세서의 명령어 인출 및 실행이 데이터 입출력이 끝난 뒤 실행</p>
<ul>
  <li>키보드, 문자 모드의 프린터와 모니터 등 저속장치에 적합</li>
</ul>

<blockquote>
  <p>🔵 상태 비트 뿐만 아니라 메인 메모리에 3비트로 구성된 채널 상태 워드(channel status word)가 존재하며, 각각 채널, 제어장치, 각 장치의 사용 가능 여부가 표시되어 있다.</p>
</blockquote>

<h4 id="4-2-인터럽트-기반-입출력-방법">4.2 인터럽트 기반 입출력 방법</h4>

<p>입출력 장치가 작업을 완료시 상태와 결과를 메모리에 저장 후, 인터럽트를 발생시켜 프로세서에게 알리는 방법</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-33-03-image.png" alt=""></p>

<p>프로세서는 이후 메모리에서 작업 결과를 확인하고 다른 입출력 명령을 전송할 수 있다.</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-33-25-image.png" alt=""><br>
위 그림은 인터럽트 기반 입출력 방법의 과정이다.</p>

<p>+ 폴링 절차 불필요, 입출력 연산 대기시간 없음<br>
+ 불규칙적이고 빠른 응답에 적합</p>

<p>- 작업 내용을 스택에 저장해야 하는 오버헤드<br>
- 프로세스 레지스터 내 모든 데이터 전송 필요</p>

<h4 id="4-3-DMA-Direct-Memory-Access-직접-메모리-제어-입출력-방법">4.3 DMA(Direct Memory Access, 직접 메모리 제어) 입출력 방법</h4>
<p>입출력 모듈이 프로세서의 도움 없이 메인 메모리를 직접 제어해 데이터를 전송</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-33-57-image.png" alt=""></p>

<p>DMA 입출력의 기본 구성은 위와 같다.</p>

<p>입출력 장치를 위한 메모리에 연속된 일부분을 할당한다.</p>

<p>DMA 제어기</p>
<ul>
  <li>입출력 중 모든 버스 제어 신호를 생성 및 제어하므로 버스 마스터 역할을 맡기도 함.</li>
  <li>버스 우선순위가 높기 때문에 버스와 메모리를 프로세서가 사용할 때 사이클 스틸링 하기도 함.
    <ul>
      <li>사이클 스틸링(cycle stealing) : 프로세서 도움없이 메모리 접근, 독점적으로 액세스</li>
      <li>프로세서의 속도를 떨어뜨리지만, 입출력 작업을 DMA에 전담시켜 전체 성능 향상</li>
    </ul>
  </li>
  <li>통용적으로 사용되는 물리적 주소 말고 직접 가상 주소 액세스(DVMA, Direct Virtual Memory Access)를 이용해 메모리에 액세스 하기도 함</li>
</ul>

<p>+ 프로세서는 이 과정에 개입하지 않으므로 프로세서 부담이 적어</p>

<p>+ 디스크 데이터 전성과 멀티미디어 같은 대용량 데이터 전송에 적합</p>

<p>- 외부 제어기, DMA 제어기 등의 하드웨어가 필요</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-34-20-image.png" alt=""></p>

<ol>
  <li>프로세서가 읽기와 쓰기 정보, 입출력 주소와 메모리 주소, 길이를 DMA 제어기에 전달해 입출력 요청</li>
  <li>DMA 제어기가 입출력 처리</li>
  <li>입출력 모듈이 메모리로 블록 단위로 데이터 전송</li>
  <li>DMA 제어기가 프로세서에게 인터럽트로 종료 통보</li>
  <li>프로세스가 메모리에 보관된 데이터를 사용</li>
</ol>

<p>입출력 채널 : IBM에서 DMA 제어기가 존재하는 입출력 모듈, 채널 프로그램을 통해 DMA 입출력을 수행한다.</p>

<h4 id="4-4-입출력-채널을-이용한-입출력">4.4 입출력 채널을 이용한 입출력</h4>

<p>입출력 채널 : 프로세서와 메인 메모리를 입출력 장치에 결합해 프로세서의 명령으로 입출력을 제어하는 장치</p>
<ul>
  <li>지역 기억 장치 또한 가지고 있으며, 많은 입출력 장치를 공유하고 제어</li>
  <li>입출력의 모든 동작은 프로세서의 개입없이 진행하고 종료 후, 인터럽트를 보내 완료를 보고한다.</li>
  <li>DMA 제어기(메모리 접근) + 입출력 명령어(입출력 동작 실행)
    <ul>
      <li>이때 입출력 명령어는 메인 메모리에 존재한다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-34-37-image.png" alt=""></p>

<p>그림 9-9는 입출력 채널 구조의 예이다.</p>

<p><strong>채널 경로</strong>: 여러개 존재 가능, 프로세서와 메인 메모리의 액세스를 조정할 수 있다.<br>
<strong>채널</strong> : 사이클 스틸을 사용해 메모리에 직접 접근<br>
<strong>입출력 장치</strong> : 제어장치를 사용해 채널과 연결<br>
<strong>제어 장치</strong> : 채널과 통신하고 장치를 제어, 유사한 장치끼리는 이를 공유함.</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-34-58-image.png" alt=""></p>

<p>입출력 채널 또한 그림 9-10처럼 여러개로 나뉜다.</p>

<ul>
  <li>실렉터 채널(selector channel)
    <ul>
      <li>어떤 장치를 고르고 입출력 종료할 때까지 다른 장치를 실행하지 않도록 한다.</li>
      <li>자기디스크, 테이프 같은 장치가 고속으로 전송할 때 대량의 데이터를 전용 채널로 이동할 때 다중화하는 방법</li>
    </ul>
  </li>
  <li>멀티플렉서 채널(multiplexer channel)
    <ul>
      <li>바이트 단위로 시분할해 여러 장치의 출력을 처리</li>
      <li>주로 저속, 중속 장치(카드리더, 프린터)등에 사용</li>
      <li>채널-메모리 연결이 다수의 느린 장치의 데이터 전달보다 훨씬 빠르므로 동시에 처리 가능하다.</li>
    </ul>
  </li>
  <li>블록 멀티플렉서 채널(block multiplexer channel)
    <ul>
      <li>실렉터 채널 + 멀티 플렉서, 여러 대의 고속 입출력 장치를 블록 단위로 동시 처리 가능</li>
      <li>장치 하나와 입출력 명령어 수행 후, 다른 장치로 빠르게 변환</li>
    </ul>
  </li>
</ul>

<h3 id="5-커널-입출력-서브시스템">5 커널 입출력 서브시스템</h3>
<p>입출력 모듈 : 프로세서와 장치 드라이버, 장치 간의 데이터를 전송 제어<br>
커널 : 입출력 인터페이스를 제공한다.</p>

<h4 id="5-1-커널-입출력-구조">5.1 커널 입출력 구조</h4>
<p>커널 : 입출력 서비스와 입출력 인터페이스 제공</p>

<p>응용 프로그램 : 커널이 제공하는 서비스를 각자 모델이나 제조사에 따라 액세스 가능하도록 표준함수로 제공<br>
(소프트웨어 드라이버?)</p>

<p>장치 드라이버 (하드웨어 드라이버?) :</p>
<ul>
  <li>응용 프로그램에서 제공한 함수를 수행</li>
  <li>입출력의 결과의 장치마다 차이를 표준 인터페이스로 변환하여 상위 커널 입출력 서브 시스템에 제공</li>
</ul>

<p>하드웨어: 소프트웨어 드라이버의 함수에 입출력 실행 후, 장치 드라이버에 돌려줌.</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-35-14-image.png" alt=""></p>

<h4 id="5-2-커널이-제공하는-입출력-서비스">5.2 커널이 제공하는 입출력 서비스</h4>

<p>커널 입출력 서브 시스템은 아래와 같은 다양한 서비스를 제공해 컴퓨터 효율성을 증진시킨다.</p>

<ul>
  <li>
    <p><strong>입출력 스케줄링</strong><br>
  입출력 요구를 전반적인 시스템 성능 향상을 위해 공평하게 처리하도록 실행 순서를 결정</p>
  </li>
  <li>
    <p><strong>버퍼링</strong><br>
  입출력 장치와 응용 프로그램 사이에 전송되는 데이터를 버퍼에 임시로 저장하는 방법</p>

    <p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-35-29-image.png" alt=""><br>
  그림 9-12의 (a)의 경우 데이터가 디스크에 도착할 때까지 기다려야 한다.<br>
  (b)의 경우, 메모리에 버퍼를 만들어, 버퍼가 찬 이후 한꺼번에 전송하기 때문에 디스크는 그 동안 다른 일을 할 수 있다.<br>
  (c)의 경우, 추가로 버퍼를 하나 추가하여, 버퍼의 데이터가 디스크에 쓰여지고 있는 와중에도 전송을 할 수 있게 해준다.</p>

    <p>추가로 버퍼를 통해 패킷 등의 데이터의 단위를 변환하기도 한다.</p>
  </li>
  <li>
    <p><strong>캐싱</strong><br>
  명령어와 데이터를 캐시에 일시적으로 저장하여 프로세서와 메모리 간의 액세스 속도 차이를 줄여 컴퓨터 성능을 향상</p>

    <p>버퍼와의 차이점은 캐시는 데이터의 복사본을 저장한다는 점이다.</p>

    <p>때로는 버퍼가 캐시 역할을 수행하기도, 캐시가 버퍼 역할을 수행하기도 한다.</p>

    <p>일반적으로 캐시는 RAM 보다 빠르고 크기가 작다.</p>
  </li>
  <li>
    <p><strong>스풀링</strong><br>
  하나의 출력장치로 여러 요청이 동시에 간다면, 커널은 이러한 요청을 각각 나누어 디스크 파일에 스풀링한 뒤, 큐에 삽입하여 차례대로 처리한다. 보통 커널 스레드를 이용한다.</p>
  </li>
  <li>
    <p><strong>오류 처리</strong><br>
  입출력 장치 고장, 네트워크 전송 오류로 발생하는 일시적인 고장을 해결</p>
  </li>
  <li>
    <p><strong>자료 관리</strong><br>
  입출력 구성의 상태 정보를 유지.<br>
  커널 대신 독립 프로그램이 상태 정보를 유지할 때의 장단점은 다음과 같다.</p>

    <p>+ 입출력 시스템의 구조와 설계가 간단, 운영체제 커널의 크기가 작고 유연함<br>
  - 장치 드라이버와 커널의 정보 공유로 메시지를 교환하려는 오버헤드가 증가</p>

    <p>상태 정보의 예시는 다음과 같다.</p>

    <ul>
      <li>장치 이름과 장치 액세스 제어 관리</li>
      <li>장치 할당과 입출력 스케줄링 관리</li>
      <li>버퍼링, 캐싱, 스풀링 관리</li>
      <li>장치 상태 모니터링과 오류 처리, 고장 복구 관리</li>
    </ul>
  </li>
</ul>

<h2 id="02-디스크의-구조와-스케줄링">02 디스크의 구조와 스케줄링</h2>

<h3 id="1-디스크의-구조">1 디스크의 구조</h3>

<ul>
  <li>보조기억 장치의 목적: 방대한 데이터를 낮은 가격으로 영구히 저장하는 것.</li>
  <li>메모리에 비해 접근 시간이 느리고 순차 접근만 허용</li>
  <li>주로 자기 디스크가 사용된다. 최근에는 SSD로 넘어가는 추세지만 여전히 자기 디스크가 싸다.</li>
  <li>디스크는 컴퓨터 장치 중 가장 느려 시스템 전체의 성능과 신뢰성에 많은 영향을 끼치므로, 메모리나 캐시 등이 발달해도 여전히 중요함</li>
</ul>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-38-21-image.png" alt=""></p>

<p><strong>디스크의 원리</strong></p>
<ul>
  <li>양 표면에 자기 물질을 입힌 원판 모양의 디스크에 정보를 기록</li>
  <li>표면을 여러 논리적 트랙으로 나누고 입출력 헤드를 통해 기록한다.</li>
</ul>

<p><strong>헤드 이동 방식</strong><br>
그림 9-13(a)의 경우 트랙마다 고정 헤드가 존재하는 고정 헤드 디스크이며, 그림 9-13(b)은 이동 헤드 디스크로, 헤드를 암 이동 장치를 이용해 이동시키는 방식이다.</p>

<p><strong>디스크 성능 높이기</strong><br>
그림 (b)처럼 디스크를 한축에 여러개 쌓거나 양면으로 이용해 저장 공간을 늘리거나, 램  디스크, 고속 디스크를 이용해 빠르게 데이터 전송을 할 수 있게 한다.</p>

<p><strong>디스크 시스템 구성</strong></p>
<ul>
  <li>디스크 드라이버 : 디스크의 기계적 동작 제어 담당
    <ul>
      <li>구동 모터</li>
      <li>액세스 암 이동장치</li>
      <li>입출력 헤드</li>
    </ul>
  </li>
  <li>디스크 프로세서 : 원하는 데이터 위치(주소)와 버퍼, 판독, 기록 등 을 관리</li>
  <li>디스크 제어기 : 디스크 드라이버의 인터페이스</li>
</ul>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-38-36-image.png" alt=""></p>

<p><strong>디스크 작동 순서</strong></p>
<ol>
  <li>디스크 제어기가 프로세서에게 명령을 받음</li>
  <li>디스크 제이기를 통해 디스크 드라이버 작동</li>
  <li>디스크 드라이버가 탐색, 기록, 판독 등을 수행
    <ul>
      <li>이때, 디스크의 주소는 드라이버 번호, 표면 번호, 트랙 번호로 구성됨<br>
    - <strong>트랙(track)</strong>: 원형 평판 표면에 데이터를 저장 할 수 있는 동심원, 자기장 간섭을 막고, 헤드 정렬을 위해 일정한 이격으로 구분<br>
    - <strong>실린더(cylinder)</strong> : 동일한 동심원으로 구성된 모든 트랙의 집합, 헤드의 움직임 없이 액세스할 수 있는 모든 트랙들<br>
    - <strong>섹터(sector)</strong> : 트랙을 부채꼴 모양으로 나눔, 섹터는 트랙을 하드웨어적으로 일정 크기로 고정되어 나뉘면서 생긴다. 기록의 기본 단위로 보통 512바이트이며, 고유 번호가 존재해 위치 판별에 쓰임</li>
    </ul>
  </li>
</ol>

<h3 id="2-디스크-액세스-시간">2 디스크 액세스 시간</h3>
<p>디스크의 섹터를 액세스할 수 있는 시간, 탐색 시간 + 회전 지연시간 + 전송 시간으로 이루어져 있다.<br>
<img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-39-02-image.png" alt=""></p>
<ul>
  <li>탐색 시간(seek time) : 헤드를 해당 트랙이나 실린더에 위치시켜 원하는 섹터에 접근하는데 걸리는 시간
    <ul>
      <li>고정 헤드 디스크는 각 트랙마다 헤드가 있으므로 0</li>
    </ul>
  </li>
  <li>회전 지연 시간 : 헤드가 지정된 트랙의 원하는 섹터가 입출력 헤드 아래로 회전할 때까지 기다려야 하는 시간</li>
  <li>전송 시간 : 디스크와 메인 메모리 간의 섹터를 주고 받는데 걸리는 시간</li>
</ul>

<p><strong>디스크 주소 표현</strong><br>
메모리와 디스크 사이의 입출력은 하나 이상의 섹터 단위로 전송하며, 디스크 주소 b는 다음과 같이 표현한다.<br>
트랙당 섹터 수=s<br>
실린더당 트랙 수=t<br>
실린더 번호=i<br>
표면 번호=j<br>
\(b= k+s\times(j+i\times t)\)<br>
블록 b+1을 액세스 할대는 헤드가 한 트랙만 옮기면 된다.</p>

<p>디스크에는 어떤 파일이 있는지 표시하는 장치 디렉터리가 있으며, 장치 디렉터리는 파일 이름으로 리스트를 나타낸다.</p>
<ul>
  <li>파일의 길이</li>
  <li>파일의 종류</li>
  <li>파일의 소유주</li>
  <li>생성된 날짜</li>
  <li>사용한 시간</li>
  <li>부호<br>
등의 파일 정보를 포함한다.
    <h3 id="3-디스크-스케줄링의-개념과-종류">3 디스크 스케줄링의 개념과 종류</h3>
  </li>
</ul>

<p>입출력장치(디스크 드라이버)에는 요청 큐가 있으며, 다음과 같은 정보를 포함한다.</p>
<ul>
  <li>입력, 출력 구분 정보</li>
  <li>디스크 주소</li>
  <li>메모리 주소</li>
  <li>전송할 정보의 총량(바이트, 워드 기준)</li>
</ul>

<p>이후, 디스크 드라이버와 제어기를 사용할 수 있을 때까지 큐에서 대기하며, 다음과 같은 기준으로 순서를 평가하는 알고리즘을 쓴다.</p>
<ul>
  <li>처리량 최대화: 시간당 처리한 서비스 요청 수</li>
  <li>탐색 시간 최소화: 디스크 헤드 이동 시간</li>
  <li>평균 반응시간 최소화: 요청 후 서비스 할 때까지 대기시간</li>
  <li>반응(응답) 시간 변화 최소화: 반응시간 예측 정도, 무기한 연기 방지, 예측 가능한 응답시간</li>
</ul>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-39-34-image.png" alt=""></p>

<p>디스크 스케줄링은 크게 탐색 시간 최적화와 회전 지연시간 최적화 알고리즘으로 분류된다.<br>
최근 디스크는 탐색 시간과 평균 지연 시간이 비슷하고 대화식 프로세스가 많아 회전 최적화로 성능을 개선한다. <br>
일괄 처리 프로세스는 데이터 트랙 전체를 액세스 하기 때문에 탐색 시간 최적화가 낫다.</p>
<h3 id="탐색-시간-최적화">탐색 시간 최적화</h3>
<h4 id="4-선입선처리-FCFS-First-Come-First-Served-스케줄링">4 선입선처리(FCFS, First Come First Served) 스케줄링</h4>
<p>요청이 도착한 순서에 따라 처리하는 가장 쉽고 간단한 알고리즘</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-39-55-image.png" alt=""></p>

<p>+ 구현이 쉽다<br>
+ 무기한 연기 없이 공평하다.<br>
+ 실행 시간 오버헤드가 적다</p>

<p>- 서비스 지연 요청(헤드에서 먼 요청)에 의한 탐색 시간 증가<br>
- 처리량 감소</p>
<h4 id="5-최소-탐색-시간-SSTF-Shortest-Seek-Time-First-우선-스케줄링">5 최소 탐색 시간(SSTF, Shortest Seek Time First)우선 스케줄링</h4>
<p>현재 헤드 위치에서 가까운 요청부터 처리하는 방법<br>
<img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-40-07-image.png" alt=""><br>
+ 비교적 처리량 증가, 반응시간 감소<br>
+ 일괄 배치 처리 시스템에 적합</p>

<p>- 예측 불가한 처리 시간, 대화형 시스템에 부적합<br>
- 공정성 없음, 디스크 요구의 기아 발생 가능</p>
<ul>
  <li>만약, 0 위치에 헤드가 존재할 때, 1~10 위치의 요청이 무한히 발생한다면, 120 위치의 요청은 영원히 실행되지 않을 것</li>
</ul>

<h4 id="6-스캔-SCAN-스케줄링">6 스캔(SCAN) 스케줄링</h4>
<p>헤드가 디스크의 한쪽 끝과 다른 끝 사이를 계속해서 왕복하면서 한 방향으로만 서비스하다 디스크 가장 자리에 도달하면 역방향으로 전환하는 스케줄링<br>
엘리베이터의 동작과 유사해 엘리베이터 스케줄링이라고도 한다.</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-40-20-image.png" alt=""></p>

<p>위 그림은 스캔 스케줄링의 예시로, 반대 방향으로 먼저 가도 스캔 스케줄링이다.</p>

<p>만약, 새로운 요청이 헤드의 경로 바로 앞에 생성되면, 다른 앞선 요청들 보다 먼저 처리한다.</p>

<p>반대로 새로운 요청이 헤드의 경로 바로 뒤에 생성되면, 다시 돌아올 때까지 오랫동안 기다려야 한다.</p>

<h4 id="7-순환-스캔-C-SCAN-Circular-SCAN-스케줄링">7 순환 스캔(C-SCAN, Circular-SCAN) 스케줄링</h4>
<p>헤드가 한쪽 방향으로 이동하다 한쪽 끝에 다다르면 반대쪽 끝으로 즉시 이동한 뒤, 같은 방향으로 진행하는 방식이다.<br>
<img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-40-34-image.png" alt=""><br>
스캔 스케줄링의 변형이며, 대기시간을 좀더 균등하게 하고, 처리량을 향상 시킨다.</p>

<h4 id="8-N-단계-스캔-스케줄링">8 N-단계 스캔 스케줄링</h4>
<p>디스크 요청 큐를 N개의 서브큐로 분할 하고, 각 서브 큐 내부 스캔을 사용해 하나씩 처리하는 방법<br>
N이 크면 스캔 알고리즘 N=1이면 선입 선처리 알고리즘과 동일하다.<br>
유연하지만 복잡하다.</p>

<h4 id="9-룩-LOOK-C-LOOK-스케줄링">9 룩(LOOK, C-LOOK) 스케줄링</h4>
<p>순환 스케줄링처럼 이동하다, 현재 방향 경로에 요청이 없다면 경로를 바꾸는 알고리즘<br>
룩은 진행 방향으로 움직이기 전에 요청을 검사하기 때문에 생긴 이름이다.<br>
<img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-42-03-image.png" alt=""><br>
스캔 스케줄링 보다 더 효율적이다.</p>

<h3 id="회전-지연시간-최적화">회전 지연시간 최적화</h3>
<h4 id="10-최소-지연시간-우선-SLTF-Shortest-Latency-Time-First-스케줄링">10 최소 지연시간 우선(SLTF, Shortest Latency Time First) 스케줄링</h4>
<p>모든 요청 중 회전 지연 시간이 가장 짧은 요청부터 처리하기 위해 디스크 헤드가 특정 실린더에 도달 시, 해당 실린더의 모든 요청을 먼저 처리한다.<br>
<img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-42-25-image.png" alt=""><br>
정확히는, 섹터 위치에 따라 큐에 넣은 후, 가장 가까운 섹터 요청을 먼저 처리한다. 따라서 섹터 큐잉(sector queuing) 알고리즘이라고도 한다.<br>
+ 탐색 시간이 없는 고정 헤드 디스크에 효과적이다.<br>
+ 특별한 트랙마다 실린더 내에 처리 요청이 하나 이상일 때는 이동 헤드 장치에도 쓸만하다.<br>
<img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-42-50-image.png" alt=""></p>

<p>+굳이 대기큐 앞부분에 잇지 않더라도 헤드가 해당 섹터를 지나간다면 요청을 처리하도록 하여 처리율을 늘릴 수 있다.</p>

<h4 id="11-최소-위치-결정-시간-우선-SPTF-Shortest-Positioning-Time-First-스케줄링">11 최소 위치 결정 시간 우선(SPTF, Shortest Positioning Time First) 스케줄링</h4>
<p>탐색 시간과 회전 지연시간의 합이 가장 짧은 요청을 먼저 고른다.<br>
+ 처리량과 평균 반응 시간 성능이 좋다.<br>
- 가장 안쪽과 바깥쪽 실린더의 요청이 무기한 연기될 수 있다.(중간 쯤의 실린더는 평균적으로 가깝기 대문이다.)<br>
<img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-43-04-image.png" alt=""><br>
위 그림 같은 경우 긴 시간이 걸리는 회전 지연시간이 더욱 긴 A보다는 다른 트랙에 있어 탐색 시간이 더 걸리더라도 회전 지연시간이 짧은 B를 먼저 처리할 것이다.</p>

<blockquote>
  <p>🔵 에센 바흐 방법(Eschenbach Scheme)<br>
헤드는 순환 스캔 스케줄링 처럼 진행, 한쪽 방향으로 디스크를 회전 시키면서 만나는 요청을 처리<br>
+ 회전 지연시간 최소화<br>
- 요청 2개가 실린더의 동일 섹터에 있으면 하나만 처리하고 나머지 하나는 한바퀴 돈 뒤에 처리</p>
</blockquote>

<h3 id="12-디스크-스케줄링-알고리즘의-선택">12 디스크 스케줄링 알고리즘의 선택</h3>

<h4 id="스케줄링-선택법">스케줄링 선택법</h4>
<p>최소 탐색 시간 우선 스케줄링은 일반적 선택<br>
스캔, 순환 스캔 스케줄링은 디스크 부하가 클 경우 선택<br>
선입선출 스케줄링은 디스크 요청이 극단적으로 적을 때 선택</p>

<h4 id="스케줄링-성능에-영향을-끼치는-요인">스케줄링 성능에 영향을 끼치는 요인</h4>
<ul>
  <li>
    <p>요청의 형태와 수에 따라 최적의 알고리즘은 달라진다.</p>
  </li>
  <li>파일 할당 방법 또한 영향을 끼침
    <ul>
      <li>연속적으로 할당된 파일을 읽으면, 헤드 이동이 해당 연속으로 강제됨</li>
      <li>링크 파일이나 색인 파일은 디스크 여러 위치에 흩어져 반응 시간은 느리지만, 저장 효율은 높음</li>
    </ul>
  </li>
  <li>디렉토리 구조 탐색에 많은 디스크 사용이 있으므로, 디렉토리는 디스크 중간 부분에 두는 것이 효율적이다.</li>
</ul>

<h2 id="03-RAID">03 RAID</h2>

<h3 id="RAID의-소개">RAID의 소개</h3>
<ul>
  <li>RAID(Redundant Array of Inexpensive Disks(혹은 Independent Disks))는 운영체제로 여러 대의 물리적 디스크를 하나의 논리적 디스크로 인식하는 기술</li>
  <li>다수의 장치를 병렬로 구성, 처리하여 성능과 안전성을 향상 시킬 수 있음
    <h3 id="2-RAID-계층">2 RAID 계층</h3>
  </li>
  <li>방법과 용도에 따라 총 6계층으로 분류</li>
  <li>구성하기 위해 소프트웨어 RAID 카드나 물리적 RAID 카드 필요</li>
  <li>최근에는 RAID 0, RAID 1, RAID 0+1, RAID 5를 제외하고 거의 사용되지 않거나 지원하지 않는다.</li>
</ul>

<h4 id="2-1-RAID-0-스트라이핑">2.1 RAID 0(스트라이핑)</h4>
<p>일련의 데이터를 논리적 디스크 배열 하나에 일정한 크기로 나눠서 분산 저장하고, 이를 논리 디스크 하나에 저장된 것처럼 이식하는 방법<br>
일정한 섹터 혹은 블록 단위인 스트립(strip)으로 나누어 연속적인 배열 첨자와 대응되도록 순환 할당.</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-43-21-image.png" alt=""></p>

<p>그림 9-28에서 데이터 ABCD를 A, B, C, D로 병렬로 분산 저장했는데, 이 각각의 A, B, C, D를 스트립(strip)이라고 하며, 연속된 데이터 ABCD는 스트라이프(stripe)라고 한다.</p>

<p>+ 동일한 하드디스크 n대로 데이터를 병렬로 저장하여 입출력 전송시간을 n배로 늘릴 수 있다.<br>
- 한 디스크 이상에서 장애 발생 시, 데이터 손실, 즉 전송시간 n배로 늘리는 대신 안전성은 1/n배</p>

<p>주로 빠른 데이터 입출력 성능을 요구하는 중요하지 않은 동영상 편집 등에 적합하다.</p>

<h4 id="2-2-RAID-1-미러링">2.2 RAID 1(미러링)</h4>

<p>데이터 스트라이핑을 사용하면서 배열 내의 모든 디스크를 미러링(mirroring)을 통해 동일한 데이터가 있는 미러 디스크를 가진다.</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-43-37-image.png" alt=""></p>

<p>+ 드라이브 장애 발생 시 즉각 두번째 디스크로 복구 가능 안전성이 n배<br>
+ 읽기 성능 n배 향상 됨<br>
- 전체 용량의 절반을 여분의 데이터 기록에 사용하므로 디스크 공간이 두배가 필요<br>
- 쓰기 성능은 단일 드라이브와 같음</p>
<ul>
  <li>그림 9-29의 경우에는 쓰기 성능 또한 4배 증가하는게 맞다. 다만 맨 앞에 두 디스크만 있는 경우는 쓰기 성능은 1배이다.</li>
</ul>

<p>쓰기가 적고 읽기가 중요하며, 안전성이 중요한 시스템 드라이브 같은 중요한 파일에 적합</p>

<h4 id="2-3-RAID-2-허밍-코드를-이용한-중복">2.3 RAID 2(허밍 코드를 이용한 중복)</h4>
<p>데이터 스트라이핑과 오류 감지 및 수정을 위한 허밍 오류 정정 코드(Hamming Error Correcting Code, Hamming ECC)를 저장하는 드라이브로 이루어져 있다.<br>
허밍 오류 정정 코드는 패리티 비트를 이용해 디스크에 전송된 데이터 오류가 있는지 확인하고 정정한다.</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-44-03-image.png" alt=""></p>

<p>오류 정정 코드는 각 데이터 디스크에 대응하는 비트를 계산한다. <br>
그림 9-30은 데이터 A를 A0, A1, A2, A3로 스트라이핑 한다.<br>
이후 생성한 허밍코드를 패리티 디스크에 ECC/Ac, ECC/Ay, ECC/Az로 저장한다.</p>

<p>+ 실시간 오류를 감지 및 수정 가능<br>
+ 빠른 기록 속도 (스트라이핑 하므로)<br>
+ 장애 복구 능력 (오류 수정으로)<br>
+ 디스크 두개의 작은 시스템에도 적용 가능</p>

<p>- 디스크 공간 낭비<br>
- 최신 SCSI 드라이브는 자체적으로 오류 검출 능력 존재</p>

<div class="callout callout-note" id="callout-c372b94e-31a2-405a-bd03-5ec188ec6075">
      <div class="header">
        <span class="emoji">✍</span>
        <span class="title"><strong>허밍 코드
</strong></span>
        <button class="collapse">🔼</button>
      </div>
      <div class="card" name="card">
    
    <div class="content" name="content">
<p>패리티 비트를 필요한 수만큼 정해진 위치에 두어 오류가 발생했을 때 오류 발생 비트를 알아내어 정정이 가능도록 함.</p>
<ul>
  <li>허밍 코드의 비트 수 : 정보 비트의 수가 m이면 패리티 비트 수 p는 2p &gt;= m+p+1</li>
  <li>패리티 비트의 위치 : 허밍 코드의 왼쪽부터 1, 2, 4, 8, 2n-1에 위치</li>
</ul>

<p>ex) 정보 비트 4, 패리티 비트 3 (P1, P2, D1, P3, D2, D3, D4)(1,2,4번 자리에 패리티 비트 위치)</p>

</div>
    </div>
    </div>
<h4 id="2-4-RAID-3-비트-인터리브된-패리티">2.4 RAID 3(비트 인터리브된 패리티)</h4>

<p>스트라이프를 이용한 분산 저장, 별도의 드라이브 한대를 패리티 드라이브로 이용해 오류 검출과 수정에 사용함</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-44-18-image.png" alt=""></p>

<p>데이터 복구는 다른 드라이브에 기록된 정보에 XOR을 계산해 수행<br>
나머지 디스크에는 스트라이프하여 분산 저장한다.</p>

<p>+ 스트라이프에 의한 높은 데이터 전송률<br>
+ 패리티 비트를 이용한 오류 탐지 및 수정</p>

<p>- 입출력 작업을 한번에 한 요청만 실행하므로 빈번한 입출력에 좋지 않음</p>
<ul>
  <li>즉, 속도는 빠르지만 한번에 한번만 실행</li>
</ul>

<p>대형 레코드를 많이 사용하는 단일 사용자 시스템, CAD, 이미지 작업에 적합</p>

<h4 id="2-5-RAID-4-블록-인터리브된-패리티">2.5 RAID 4(블록 인터리브된 패리티)</h4>

<p>RAID 3와 비슷하지만 데이터를 블록 단위로 분산 저장하여 각 디스크에서 독립적으로 입출력을 할 수 있다.<br>
<img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-44-36-image.png" alt=""></p>

<p>기존의 비트 단위 저장의 경우 데이터 출력과 단위가 달라 의미없이 나누었지만, 블록 단위 저장의 경우 각 디스크가 데이터의 의미가 있도록 나누어, 각기 다른 입출력이 가능하다.</p>

<p>쓰기는 패리티 비트를 수정해야 하므로 느리지만 읽기는 RAID 0와 비슷한 성능을 보인다.</p>

<p>+ RAID 3의 장점에 추가로 각 디스크가 각기 입출력 진행 가능<br>
+ 저렴한 가격으로 장애복구 능력과 빠른 읽기 속도</p>

<p>- 크기가 작은 입출력의 성능이 떨어짐 (작은 변화에도 패리티 정보를 갱신해야 하므로)</p>
<ul>
  <li>따라서 높은 데이터 전송률이 필요할 때는 성능이 떨어짐</li>
</ul>

<h4 id="2-6-RAID-5-블록-인터리브된-분산-패리티-블록">2.6 RAID 5(블록 인터리브된 분산 패리티 블록)</h4>
<p>별도의 패러티 드라이브 대신 모든 드라이브에 패리티 정보를 나눠서 저장한다. <br>
<img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-44-48-image.png" alt=""><br>
다른 모든 장점을 가지고 있어 가장 널리 사용되는 RAID 방법이다.</p>

<p>+ 쓰기에서 패리티 수정 동작이 디스크 병목 현상을 일으키지 않않음<br>
+ 병렬 입출력, 동시 읽기 기록, 데이터 입출력 성능 빠름, 안정성 높음</p>

<p>- 최소 3대, 보통 5대 이상의 드라이브가 필요, 소규모 시스템 부적합<br>
- 읽기 요청은 각 드라이브에서 패리티 정보를 건너뛰어 RAID 4보다 비교적 느림</p>

<h4 id="2-7-RAID-0-1">2.7 RAID 0+1</h4>
<p>스트라이핑과 미러링 방법을 혼합한 형태</p>

<p><img src="/assets/img/OS 정리-Chap 9-입출력 시스템과 디스크 관리/2022-07-21-00-45-05-image.png" alt=""></p>

<p>+ 안전성과 빠른 속도 모두 확보</p>

<p>- 최소 4개의 디스크 필요<br>
- 미러링으로 인해 용량이 절반으로 줄어듦</p>
</body></html>
</div>

  </div><a class="u-url" href="/articles/computer_science/OS/IT_COOK_BOOK_OS_%EC%A0%95%EB%A6%AC/OS%20%EC%A0%95%EB%A6%AC-Chap%209-%EC%9E%85%EC%B6%9C%EB%A0%A5%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC%20%EB%94%94%EC%8A%A4%ED%81%AC%20%EA%B4%80%EB%A6%AC.html" hidden></a>
  <p class="u-path" hidden>_articles/computer_science/OS/IT_COOK_BOOK_OS_정리/OS 정리-Chap 9-입출력 시스템과 디스크 관리.md</p>
  <script type="module" src="/assets/scripts/utils/update_recents.js"></script>
</article>

    </div>
  </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">🧠SUBBRAIN</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="a-name">🧠SUBBRAIN</li><li><a class="u-email" href="mailto:roadvirushn@gmail.com">roadvirushn@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li>
    <a href="https://github.com/RoadVirusHN"><svg class="svg-icon">
        <use xlink:href="/assets/svg/social-icons.svg#github"></use>
      </svg>
      <span class="username">RoadVirusHN</span></a>
  </li><!---->
</ul></div>

      <div class="footer-col footer-col-3">
        <p>이것이 디지털 동물의 숲이다!! 파멸편 (This is the Digital Animal Crossing!! Bad Ending.01)</p>
      </div>
    </div>

  </div>

</footer>
</body>

<script src="/assets/scripts/bundle/common.bundle.js"></script>

</html>