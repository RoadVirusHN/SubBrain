---
title: "12. 시스템 보안과 보안 운영체제 - 운영체제 학습 정리"
date: 2022-08-11 12:34:26 +0900
tags: OS CS 요약
layout: obsidian
is_Finished: false
last_Reviewed: 2022-10-28 14:05:09 +0900
use_Mathjax: true
---
```toc

```

# 12. 시스템 보안과 보안 운영체제
```ad-quote
title: 참고 서적
[IT COOK BOOK 운영체제 (개정 3판, 구현회 저, 한빛 아카데미)](https://www.hanbit.co.kr/store/books/look.php?p_code=B3239422381)를 참고로 정리한 내용입니다.
```
## 01 보안의 개념과 보안 위협의 유형
### 1 보안의 개념
- **보호**: 컴퓨터 시스템에 저장된 프로그램과 데이터 액세스 제어 등 내적인 문제만  다룸.
- **보안**
	- 시스템, 시스템이 작동하는 외부 환경과 내부 조직 구성원의 액세스까지 보호하는 것.
```ad-note
title: 표 12-1 보안의 구분

```
| 구분        | 설명                  |
| ----------- | --------------------- |
| **기술적 보안** | - 하드웨어, 소프트웨어적 조치, 기술, 정책, 절차 포함 <br>- 시스템(네트워크, DB, 프로세스, 컴퓨터, 장비 등)이 대상 <br>- 액세스제어, 암호화, 인증, 침입 탐지 등 존재|
| **물리적 보안** | - 시설에 허가 받지 않은 접근 차단 및 모니터링<br>- 물리적 출입 제어(스마트카드, 감사 추적, 접근 이력 관리)       |
| **관리적 보안** | - 조직 내부의 정보 보호 체계 정립<br> - 절차, 감시 조직, 사고 대책 수립 등이 존재           |

여기서 다루는 것은 기술적 보안 중의 컴퓨터 보안이며, 그림 12-1과 같이 컴퓨터 액세스 보안, 네트워크 보안, 데이터 액세스 보안이 있다.
![[Pasted image 20220803231509.png]]
### 2 보안의 요구 사항
- **기밀성(confidentiality)**: 인가된 사용자만 정보 자산에 접근(조회, 복사)하게 하는 것,  방화벽, 암호 등이 존재
- **무결성(intergrity)**: 적절한 권한을 가진 사용자가 인가된 방법으로만 정보를 수정하게 하는 것, 정보의 변조, 파괴 방지, 액세스 제한 등이 존재
- **가용성(availabilty)**: 정보 자산을 필요한 시간에 접근할 수 있는 것, 빠른 접근이 예시
- **인증(authentication)**: 사용자가 누구인지 확인하는 절차, 이후 액세스 제어로 넘어감
- **액세스 제어(access control)**: 사용자가 정보를 사용할 권리가 있는지 판단 
- **권한 부여(authorization)**: 각 사용자가 적절한 권한으로 적절한 정보에 액세스할 수  허용 범위를 정의하는 과정
- **자격 증명(credential)**: 식별자 및 신분 증명이 완료된 정보로 자원에 액세스를 얻는 것 
### 3 보안 위협의 유형
![[Pasted image 20220803231559.png]]
- **중단(흐름 차단, Interruption)** : 시스템 일부를 차단하거나 사용할 수 없도록 가용성에 피해를 주는 공격
	ex) 하드웨어 파괴, 통신 회선의 절단, 파일 관리 시스템 무력화 등
- **도청(가로채기, Sniffing)**: 권한이 없는 공격자가 컴퓨터 자원에 액세스, 피해자가 눈치 채지 못한다.
	ex) 패킷 스니핑
- **변조(수정, Modification)**: 권한 없는 공격자가 컴퓨터 자원에 액세스 + 내용 변경하는 무결성 공격
	ex) 파일의 내용 수정, 프로그램 변경, 전송 메시지 변경
- **위조(조작, Fabrication)**: 권한 없는 사용자가 정보를 교체, 제거, 데이터 순서 변경을 통해 위조 객체를 삽입하는 공격, 무결성과 인증에 피해를 줌
	ex) 허위 메시지 삽입, 파일 레코드 추가 등
- **사칭(가장, Masquerade)** : 비인가 사용자가 인가 사용자로 가장, 인증에 피해

공격을 분류하면 능동적 공격과 수동적 공격으로 구분할 수 있다.
- **수동적(Passive) 공격**: 사전 계획 없이 도청, 모니터링을 통해 정보를 얻어 공격, 공격을 알아채기 힘들지만, 암호화로 쉽게 해결
	ex) 스니핑, 스캐닝(공격할만한 대상의 취약점 등을 탐색), 트래픽 분석
- **능동적(Active) 공격**:  시스템 내부의 정보를 변경, 시스템 상태와 작동을 변경하여 공격
	ex) 사칭, 변조, 서비스 거부(수 많은 연결 요청 등의 메시지를 보내 액세스 자원을 확보하여 정상적인 사용을 막음) 등이 존재 
	
그 외에 내가 조사해서 추가한 유형들
- **부인(Repudiation)**: 공격자가 자신이 보낸 메시지를 부인하여 서비스에서 이득을 취하거나 자원을 획득
- **백도어(Backdoor)**: 공격자가 미리 시스템에 침투해 향후 있을 공격을 위해 취약점을 생성해 놓음.

### 4 소프트웨어 위협
크게 호스트 프로그램이 필요한 경우와 자체적으로 위협을 가할 수 있는 경우로 나뉨

#### 4.1 컴퓨터 바이러스(computer virus)
- **정의** : 자기 자신을 스스로 복제할 수 있는 실행 가능한 명령 집합
- **피해** : 컴퓨터의 프로그램이나 프로세서의 서비스 영역에 자신 또는 자신의 변형을 복제하여 시스템에 피해를 줌
- **전파** : 사용자 권리와 네트워크를 이용해 다른 컴퓨터 시스템으로 퍼뜨릴 수 있음
- 프로세서의 서비스가 필요하므로 하드웨어의 파괴는 불가능하며 시스템이 중단 시 활동 불가
- 컴퓨터 바이러스의 주 기능
	- **자기 복제(증식) 기능**: 다른 파일과 시스템을 감염시켜 복제됨, 네트워크를 통한 이메일이 주요 매체
	- **은폐 기능**: 파일 크기나 내용을 감염 이전과 똑같이 보이게 하여 은폐, 일부 바이러스는 빠른 확산 속도 때문에 은폐하지 않음
	- **파괴 기능**: 미리 작성한 프로그램으로 특정 신호 이후 데이터 파괴, 시스템 오작동 유발

#### 4.2 웜(worm)
- 컴퓨터 시스템에 해를 끼칠 수 있는 장소에 위치하는 바이러스나 복제 코드의 일종
- 시스템 자원을 이용해 자신의 복사본 생성 후, 네트워크를 통해 전파

```ad-tip
title: 컴퓨터 바이러스과 웜의 차이점

컴퓨터 바이러스는 **다른 프로그램이나 파일을 매개로 감염시켜 복제**
웜은 **자기 자신이 프로그램이므로 자신을 복제**함
```

#### 4.3 트로이 목마(trojan horse) 프로그램
- 해로운 기능을 수행하는 은폐된 코드를 포함한 프로그램
- 자기 복제 능력은 없고 고의적으로 포함된 파괴 기능이 존재

#### 4.4 트랩 도어(trap door)
- 서비스 기술자나 유지 보수 프로그래머가 액세스 편의를 제공하려고 시스템 설계자가 만든 통로
- 이를 통해 공격자가 공격할 수 있으므로 반드시 개발 완료 후 닫아야 함.

#### 4.5 사이버 테러(cyber terror)
- 정부 기관이나 민간 기관의 정보 시스템에 침입하여 중대한 장애를 발생하거나 파괴는 범죄 행위
	- **이메일 폭탄(email bomb)**: 이메일 사용자의 이메일 프로그램을 마비 시키거나 정상적인 메일 수신을 방해하기 위해 다량의 대용량 쓰레기 메일을 발송
	- **논리 폭탄(logic bomb)**: 특정 데이터의 출현과 소멸에 따라 부정 행위를 동작하는 프로그램
	- **시한 폭탄(time bomb)**: 특정 사건이나 시스템 타이머의 시점에 바이러스나 트로이 목마 등을 운반하는 프로그램
	
## 02 시스템 보안의 개념과 액세스 제어

### 1 시스템 보안의 개념
권한이 없는 사용자가 파일, 폴더, 장치 등을 사용하는 것을 제한하여 보호하는 시스템 기능

크게 여섯 가지 주제로 집약
- **계정과 패스워드 관리** : 가장 기본적인 인증 수단
- **세션 관리**: 사용자와 시스템 또는 두 시스템 간에 활성화된 접속을 관리, 세션 가로채기를 통해 인증 공격을 받을 수 있다.
- **액세스 제어**: 시스템을 다른 시스템에서 적절히 보호할 수 있도록 접근 통제
- **권한 관리**: 시스템 각 사용자가 적절한 권한으로 적절한 정보 자산에 접근할 수 있도록 통제
- **로그 관리**: 시스템 내부 또는 네트워크의 활동 사항 기록
- **취약점 관리**: 시스템 자체의 결함 관리
### 2 액세스 제어(access control)
적절한 권한을 가진 인가자만 특정 시스템이나 정보에 접근할 수 있도록 통제

#### 2.1 사용자 액세스 제어

식별과 인증을 통해 사용자를 인증하고 비인가자를 막는다.
그림 12-3은 이러한 시스템 로그인의 예시이다.
![[Pasted image 20220803231709.png]]
시스템 자원을 보호하는 가장 기초적인 첫단계로, 식별자와 암호를 암호화하고 가용성을 위해 잘 관리해야 함.

추가적인 보안과 관리를 위해 다음을 고려할 수 있다.
- **단일 사인 온(SSO, Single Sign On)** : 사용자의 편의성을 위해 한번 인증으로 여러 자원에 접근 가능
- **2단계 액세스 제어** : 네트워크 액세스와 자원 액세스에 따로 식별자와 암호를 두게 함

![[Pasted image 20220803231740.png]]

그림 12-4는 수많은 식별자와 암호를 중앙에서 효율적으로 관리하기 위한 네트워크 액세스 분산 서비스 그림이다.

#### 2.2 데이터 액세스 제어
**액세스 행렬(access matrix)** : 파일이나 데이터베이스에서는 각각의 객체에 대한 엑세스 권한을 관리하기 위한 권한의 집합
- 주로 행은 주체, 열은 객체(파일, 테이블, 프로그램, 메모리 세그먼트), 각 항은 액세스 권한의 집합
```ad-note
title: 액세스 행렬 예시

| 사용자\\객체 | 파일 $F_1$ | 파일 $F_2$ | 파일 $F_3$ | 프로그램 | 프린터 |
| :------------: | :----: | :----: | :----: | :--------: | :------: |
| A            |  r    |      | r     |          |        |
| B            |      |      |      |  x        | r       |
| C            |      |    r  | x     |          |        |
| D             |   rw   |      |  rw    |          |        |
`r`: 읽기 권한, `w`: 쓰기 권한, `x`: 실행 권한
```
액세스 행렬은 위와 같이 간단하지만 빈 공간이 많아 저장 공간이 낭비됨

이를 막기 위해 [희소행렬의 자료구조 저장법](https://ko.wikipedia.org/wiki/%ED%9D%AC%EC%86%8C%ED%96%89%EB%A0%AC)을 이용할 수 있지만, 보호 설비의 특성상 사용 힘듦

다음은 액세스 행렬을 표현하는 다른 방법들이다.

##### 전역 테이블(global table)
<사용자, 객체, 권한> 3개의 순서쌍을 이용해 집합을 구성하는 방법

```ad-note
title: 전역 테이블 예시
| 사용자($D_i$) | 객체($O_j$) | 권한 |
| :-------------: | :-----------: | :----: |
| A             |   $F_1$          | r     |
| A             |     $F_3$        |  r    |
| B             |         프로그램    | x     |
| B             |    프린터         |    r  |
| C             |     $F_2$        |     r |
| C             |      $F_3$       |      x|
| D             |       $F_1$      |   rw   |
| D             |        $F_3$     |    rw  |
```

➕공백으로  인한 저장 공간 낭비 해결
➖ 테이블이 여전히 매우 큼
	- 어떤 객체가 모든 사용자에게 사용 가능하다면 모든 사용자마다 한 항목이 존재
	- 메모리에 담을 수 없으며, 가상 메모리를 이용하기 힘듦

##### 액세스 제어 리스트(access control list)
각 객체 리스트는 <사용자, 권한> 순서쌍으로 구성되어 해당 객체에 액세스 권한이 있는 모든 사용자 영역을 정의

![[Pasted image 20220803232106.png]]

➕ 사용자 입장에서 효율적으로 사용 가능
	- 사용자가 객체를 만들면 해당 객체에 대한 사용 가능 사용자와 연산을 만들어 추가하면 됨
➖ 액세스 권한이 지역화 되지 않음
	- 사용자 A만 사용하고 있으면 나머지 사용자 B, C 정보는 필요 없으나 분리하지 못하고 전부 가져와야 함
➖ 객체 접근 마다 액세스 제어 리스트를 모두 탐색해야 함.

**기준치 집합**: 탐색 시간을 줄이기 위해 미리 정의한 기본적인 권한에 대한 집합?(🤔)

##### 권한 리스트
액세스 제어 리스트와 비슷하지만 각 행을 사용자로 놓고 객체와 그 객체에 허용된 동작의 리스트를 생성하는 방식.

![[Pasted image 20220803232202.png]]

➕ 특정 사용자의 리스트만 읽어 들인 후, 해당 파일의 권한만 찾으면 되므로, 지역화가 쉬움(가상 메모리 활용이 쉬움)
➕ 해당 사용자의 리스트만 읽으면 되므로 탐색 불필요

➖ 사용자가 객체를 만들면, 해당 객체에 권한을 가진 모든 사용자의 리스트를 생성해야 함

권한 리스트는 모두 운영체제가 유지하고 사용자가 간접적으로 액세스할 수 있다. 

➕ 권한을 운영체제가 보호하므로 객체 또한 보호할 수 있다.

➖ 권한의 변경이 성능적으로 비효율적, ∵ 해당 권한 데이터를 담은 객체를 다른 객체와 구별하기 위해 고수준의 소프트웨어로 번역해야 함.
- 크게 두 가지 방법으로 데이터를 구분한다.
	- 각 개체의 권한과 액세스 가능 여부를 비트로 표현한 태그로 표현, 운영체제만 접근, 변경 가능
	- 프로그램의 메모리 부분을 두 부분으로 나눔
		- 보통 데이터와 명령을 담은 부분
		- 운영체제만 접근 가능한 권한 리스트를 포함한 부분

##### 락/키(lock/key) 방법

- 위 두 방법의 절충안, 대부분 시스템에서 사용
- **락(lock)** : 각 객체들이 가지고 있는 유일하고 독특한 비트 패턴의 리스트
- **키(key)** : 각 사용자들이 가지고 있는 유일하고 독특한 비트 패턴의 리스트
- 락/키 방법 순서
	1 . 프로세스가 운영체제에 객체에 접근 요청
	2. 해당 프로세스를 실행한 사용자의 키의 비트 패턴들과 해당 객체의 락의 비트 패턴들을 모두 비교
	3. 일치하는 패턴이 존재하면 접근 가능

![[Pasted image 20220803232222.png]]

➕ 키의 길이에 따라 융통성 있고 효율적임
- 비트 연산이 빨라서 효율적인가?🤔
➕ 사용자 영역 간에 자유롭게 키 교환 가능(사용자 그룹 기능을 의미하는가? 🤔)
➕ 권한 리스트처럼 운영체제가 관리하므로, 동일한 장점 공유(객체 보호 가능) 

## 03 시스템 보안 방법

### 1 암호화
암호화는 신뢰할 수 없는 연결(=즉, 탈취나 도청 가능성이 있는)을 이용할 때 정보를 보호하는 방법이다.

복호화를 위한 키가 없는 공격자는 정보를 알 수 없다.

다음은 암호의 기능이다.
- **비밀성**: 통신망을 이용한 정보 전송이나 시스템에 저장된 정보 노출 방지
- **인증**: 액세스 하려는 사용자의 확인 및 사용자의 권한 방지
- **무결성 검사**: 메시지나 파일 변조가 없음을 보장
- **전자 서명**: 인증과 무결성 검사 기능으로 신원 확인 + 해당 정보에 대한 동작(생성, 전송)을 보장

크게 대칭 암호화와 비대칭 암호화로 나뉜다.
#### 1.1 대칭 암호화
대칭 암호화 혹은 단일키 암호화는 동일한 키를 이용해 암호화와 복호화하는 방식이다.
![[Pasted image 20220803232340.png]]
 대표적으로 IBM이 개발하고 NIST가 표준화한 DES(Data Encrpytion Standard)가 있다.

➕ 비대칭 암호화에 비해 성능에 부담이 적고, 직관적이다.
➖ 비밀키를 상대방에게 건네주는 방법이 필요

#### 1.2 비대칭(공개키) 암호화
- 1976년 디피(Diffie), 헬먼(Hellman)이 발표한 알고리즘
![[Pasted image 20220803232353.png]]
- 각 사용자는 공개키와 개인키를 별도로 가지고 있다.
- 공개키는 모든 사용자에게 공개되어있으며, 암호화할 때 사용한다.
- 개인키는 오직 개인만이 가지고 있으며, 복호화할 때 사용한다.

```ad-tip
title: 개인키와 공개키의 변환

반대로, 개인키를 암호화할 때 사용하면, 공개키로 복호화할 수 있다.
이렇게 서로가 암호화한 암호문을 복호화할 수 있는 능력으로 디지털 서명에도 쓰인다.
```

- RSA 암호화 알고리즘이 대표적

➕ 대칭키를 암호화하여 건네주기, 자격 증명, 전자 서명 등 다양한 곳에 사용될 수 있음
➖ 대칭키 방식에 비해 성능 부담이 큼

### 2 인증
서로 교환하는 정보의 무결성을 확인하는 메시지 인증과 송수신자의 정당성을 확인하는 사용자 인증으로 구분한다.

#### 2.1 메시지 인증(MAC, Message Authentication Code)
메시지 인증 코드(MAC) 메시지의 끝에 넣어 인증하는 방식 

다음과 같은 변경을 탐지할 수 있다.
- 메시지 전송 중에 수신자의 변경 여부 
- 메시지 내용의 변경 여부
- 메시지 순서의 변경 여부
![[Pasted image 20220803232422.png]]
1. MAC 알고리즘에 두 사람이 공유하는 비밀키와 메시지를 이용해 MAC를 만든다.
2. 해당 MAC를 전송할 메시지에 덧붙인다.
3. 이후 수신자는 비밀키와 메시지를 이용해 만든 MAC와 메시지 뒤편에 붙은 MAC를 비교해 변경 여부를 확인한다.

만약, 중간에 메시지가 변경되었다면 다른 MAC값이 나올 것이다.
MAC 또한 조작하려면 공격자가 비밀키를 가지고 있어야 한다.

![[Pasted image 20220803232449.png]]
HMAC는 MAC를 만드는 함수로 해시 함수를 이용하는 방법이다.
#### 2.2 사용자 인증
사용자 인증은 아이디, 암호 입력 등 특별한 과정을 거쳐 서버의 특정 디렉터리를 사용할 수 있도록 하는 방법으로 사이버 공간에서 신원을 확인할 수 있게 함
![[Pasted image 20220803232506.png]]

주로 암호를 이용하지만 그림 12-13처럼 공개키를 이용하여 인증할 수 있다.

송신자가 개인키로 암호화한 암호문은 A의 공개키를 이용해서만 인증되므로, A의 개인키를 가진 A임이 인증된다.

### 3 디지털 서명(digital signature)
디지털 서명은 
- 부인 봉쇄 : 메시지를 송수신 시 해당자가 송수신 행위를 부인하는 행위 방지
- 인증
- 데이터 변조 검증
에 사용

주로 비대칭키를 이용하여 진행된다.
![[Pasted image 20220803232529.png]]
1. 송신자 B가 자신의 개인키로 암호화
2. 송신자 B가 송신자 A의 공개키로 다시 암호화
3. 수신자 A에게 전송
4. 수신자 A가 먼저 자신의 개인키로 복호화, 이를 통해 자신을 위해 보낸 것이 증명
5. 수신자 A가 송신자 B의 공개키로 복호화, 이를 통해 송신자 B가 보낸 것이 증명
![[Pasted image 20220803232557.png]]
### 4 네트워크 보안
#### 4.1 방화벽(firewall)
방화벽 혹은 침입 차단 시스템은 다른 네트워크의 사용자에게서 네트워크 자원을 보호하는 프로그램

##### 방화벽의 기능
- 도메인 확인: 확인된 도메인 이름이나 IP 주소인지 확인해 접속 허용
- 원격 접속 확인: 보안 접속 절차나 인증 확인 등을 이용해 네트워크 원격 접속 허용

##### 방화벽의 목적
- 비공개 자원 외부 액세스 방지
- 내부에서 접속해야 할 외부 자원 통제

##### 방화벽의 원리
네트워크 패킷의 헤더와 페이로드를 검사하여 판단

##### 방화벽의 한계
악의적인 내부 사용자의 공격 방지 못함
조사 시간으로 인해 통신 병목 지점이 될 수 있음

#### 4.2 침입 탐지 시스템(IDS, Intrusion Detection System)

정보 시스템의 비밀성, 무결성, 가용성을 침해하는 모든 행위를 탐지하는 적극적 보안 시스템

##### IDS의 목적
침입 사실을 빠르게 검출하고 침입자를 봉쇄하여 시스템 손실과 데이터 훼손 최소화

##### IDS의 기능
- 시스템에서 의심나는 점을 감시, 조사하여 필요한 조치를 취함
- 비정상적인 사용이나 잘못된 사용 등 기준이나 규정을 벗어나는 행위 발견 시, 침입 과정을 로그에 기록하고 위험을 알림
- 방화벽 경계선을 통과한 공격이나 내부자 오남용 탐지

![[Pasted image 20220803232636.png]]
##### IDS 설치 위치에 따른 역할
- **라우터와 외부 인터넷 사이**: 모든 공격 탐지 가능, 너무 많은 패킷으로 인해 비효율적
- **라우터 뒤**: 라우터의 패킷 필터링 이후에 탐지, 좀더 의지가 분명한 공격자 탐지
- **방화벽 뒤**: 영향을 받지않고 공격을 막는 마지막 부분, 내부에서 외부로 향하는 공격도 탐지 가능, 가장 많이 설치되는 부분
- **내부 네트워크**: 내부의 악성 사용자의 해킹을 감지 가능
- **서버 네트워크(DMZ 내)**: 중요 데이터와 자원을 보호하기 위해 IDS 별도 운영

```ad-note
title: DMZ(DeMilitalized Zone)?

네트워크의 내부 사용자와 외부 사용자가 모두 사용하는 네트워크
철저한 보안과 인증이 필요하며, 서비스의 중축이 되는 경우가 많다.

예를 들어, 페이스북의 백엔드 서버와 프론트엔드 서버는 페이스북 개발자들은 유지보수 및 개발을 위해 접근하며, 외부 사용자들은 서비스 사용을 위해 접근한다.
```

#### 4.3 트래픽 패딩(traffic padding)

트래픽양 분석 공격을 방어하기 위해 정상적인 메시지에 추가로 가짜 암호 메시지를 보내는 것.
![[Pasted image 20220803232654.png]]

- 만약, 아무런 암호문을 보내지 않는 상황에는 의미없는 암호문을 생성해 주기적으로 송신 👉 트래픽 사용 주기 파악 불가능
- 암호문을 보낼 때는 일정한 길이가 되도록 의미없는 데이터를 덧붙인 뒤에 암호화하여 송신 👉 패킷 길이 정보를 통한 메시지 내용 예측 불가능

이때, 의미 없는 데이터를 덧붙인 암호문의 길이는 실제 데이터 트래픽에 발생 가능한 패킷의 길이보다 길어야 함. 

## 04 보안 운영체제

### 1 보안 운영체제(secure OS)의 개념
운영체제에 내재된 결함을 발생할 수 있는 각종 해킹에서 보호하기 위해 보안 기능이 통합된 보안 커널을 추가로 이식한 운영체제

이러한 보안 운영체제를 탑재한 컴퓨터를 신뢰 시스템(trusted system)이라고 한다.

##### 보안 운영체제의 기능
- 시스템 사용자 식별, 인증
- 강제적이고 임의적인 액세스 제어
- 감사 추적(audit & trail)
- 위협 모니터링(threat monitoring)을 통한 침입 탐지

![[Pasted image 20220803232721.png]]
특히, 내부 사용자 보안을 강력하게 유지 가능

커널의 참조 모니터 모듈을 이용해 사용자가 파일, 디렉터리, 디바이스 등에 연산 요청 시, 액세스를 제어해 승인과 거절을 수행한다.

```ad-note
title: TCSEC(Trusted Computer System Evaluation Criteria)

![[Pasted image 20220803232746.png]]
신뢰성 컴퓨터 시스템 평가 기준, 일곱 가지 등급(D~A1)으로 분류
컴퓨터 보안 요구사항을 규정하여 보안 커널로 구현하게 함.
```
### 2 보안 운영체제의 기능
강력하고 완벽한 보안을 구현하려면 시스템 구조부터 뒤바뀌어야 한다.

보안 운영체제는 기존의 실행 환경을 유지하면서 강력한 보안 기능을 제공하기 위해 다음 등의 기능을 가지고 있다.

#### 2.1 영역 분리

응용 프로그램이나 사용자 역할에 따라 액세스할 수 있는 정보 영역과 시스템의 제어 권한을 제한

ex) 웹 서버와 관련된 프로세스가 해커의 공격을 받아 뚫려도 DB에는 접근 못하게 원천적으로 권한 제한 

#### 2.2 강제적 액세스 제어(mandatory access control)

사용자나 프로세스가 객체에 액세스 시, 신분이나 규칙으로 해당 객체 액세스를 커널 수준에서 제어

![[Pasted image 20220803232808.png]]
사용자에게는 액세스 가능한 범위를 나타내는 보안 등급을,
객체에는 허용 할 수 있는 기밀 수준을 할당한다.

시스템 내부의 요소를 좀 더 세분화하여 여러 정책을 가진다.
- **액세스 제어 정책**: 주체가 객체에 액세스 하는 방법 지정
- **인증 사용 정책**: 사용자 인증에 사용
- **암호 사용 정책**: 저장 전송하는 데이터를 보호하는 데 사용

➕ 메모리, 커널 수준의 액세스 제어를 통한 강력한 보안
➕ 시스템 과부화 감소

#### 2.3 신뢰할 수 있는 경로(보호된 경로,  trusted path)

- 소프트웨어와 함께 상호 동작하는 사용자를 허가하는 기능
- 주체가 객체에 접근하는 방법을 운영체제가 강제함

소프트웨어 요소 간에 상호 보증할 수 있고 신뢰할 수 있는 보호된 경로의 채널을 사용하기 위함이다.

만약, 이가 없다면, 철저한 보안이 갖춰지더라도 공격자가 사용자에게 취약한 경로를 이용하게 하여 공격할 수 있다. 

#### 2.4 참조 모니터(reference monitor)
객체의 모든 액세스를 제어하는 추상적인 장치
주체와 객체 사이의 중계자 역할을 함

![[Pasted image 20220803232837.png]]

주체와 객체의 보안 매개변수를 이용해 자원 액세스 제어 기능을 수행

이때 액세스 여부는 다른 보안 방법(인증, 영역 분리 등)들과 데이터를 교환하면서 결정

##### 참조 모니터 구현 요구 사항
- 액세스 제어 방법은 변조 불가
- 모든 액세스 요청은 참조 모니터를 통해야 함
- 다른 많은 보안 방법과 상호작용 하면서 모든 액세스 요청을 분석과 시험해야 함 ∴ 성능 과부화를 줄이기 위해 작아야 하며, 보통 추가적인 하드웨어 구성을 함

#### 2.5 감사 로그 추적(audit log trail)

사용자가 시스템에 액세스한 후 입력한 검색어, 검색 대상의 활동 내역을 기록하고 저장하여 일련의 기록을 조사하는 것

- **감사 로그(audit log)**: 단순히 시간, 사용자, 객체에서 모든 액세스 형태를 기록한 파일, 특정 서버의 로그 디렉터리에 위치
	- 감사 로그를 통해 피해 정보와 시간과 장소를 알 수 있고 이를 통해 예방 가능
	- 침입 탐지 시스템이 읽으며 침입을 탐지

![[Pasted image 20220803232902.png]]

##### 감사 로그 필드 예시
- **주체**
- **행위**: 주체의 동작(로그인, 읽기, 입출력 수행, 실행)
- **객체**
- **예외 조건**
- **자원 사용량**: 프로세서 시간, 출력 행 수, 읽은 레코드 수
- **시간 검인(timestamp)**: 행위가 발생한 시간

```ad-example
title: (a) 스미스가 <Library> 디렉터리의 GAME 실행 프로그램 복사 명령 감사 로그 예시
COPY GAME.EXE TO <Library>GAME.EXE
```
- 위 예시는 실패하여 아래 (b)와 같은 감사 로그를 생성한다.

```ad-example
title: (b)생성된 감사 로그
(Smith, execute, <Library>COPY.EXE, 0, CPU=00002, 11058521678)
(Smith, read, <Smith>GAME.EXE, 0, RECORDS=0, 11058521679)
(Smith, write, <Library>GAME.EXE, write-viol, RECORDS=0, 11058521680)
```

감사 자료 또한 공격자가 조작할 수 없도록 보안성이 필요하며, 이는 커널 수준에서 구현하여 차단 가능하다.