---
title: "11. 분산 및 다중(병렬) 처리 시스템 - 운영체제 학습 정리"
date: 2022-08-11 10:34:26 +0900
tags: OS CS 컴퓨터_구조 요약
layout: obsidian
is_Finished: false
last_Reviewed: 2022-10-28 14:05:09 +0900
use_Mathjax: true
---
```toc

```

# 11. 분산 및 다중(병렬) 처리 시스템
```ad-quote
title: 참고 서적
[IT COOK BOOK 운영체제 (개정 3판, 구현회 저, 한빛 아카데미)](https://www.hanbit.co.kr/store/books/look.php?p_code=B3239422381)를 참고로 정리한 내용입니다.
```
## 01 분산 시스템
### 1 네트워크와 분산 시스템
**분산 처리**
- 컴퓨터 사용자 간에 서로의 자원, 장치, 데이터를 교환해 처리할 수 있도록 네트워크로 상호 연결한 것이다. 

**네트워크 연결 시스템의 분류**
- 분산 시스템 : 메모리와 클록을 공유하지 않고, 지역 메모리를 유지하는 독자적 프로세서들로 구성
- 다중 처리 시스템(병렬 처리 시스템) : 메모리와 출력을 공유하는 하나 이상의 프로세서로 구성

### 2 네트워크의 구성

- 네트워크란, 서로 독립 된 시스템들이 적절한 영역 안에서 속도가 빠른 통신 채널을 이용해 상호 통신할 수 있도록 지원하는 데이터 통신 시스템
- 분산 시스템에서 네트워크는 원거리의 하드웨어나 소프트웨어 자원에 액세스할 수 있는 기능 제공
- 크게 강결합과 약결합 시스템으로 이루어짐 
#### 2.1 강결합(tightly coupled) 시스템
![](2022-07-29-19-12-40-image.png)

그림 11-1과 같이 프로세서들이 메모리를 공유하는 다중 처리 시스템.
공유 메모리를 이용해 통신하므로, 결합 교환을 통해 경쟁을 최소화
```ad-note
title: 결합교환(combining switch)이란?

메모리를 요청한 프로세서들 중 하나에게만 액세스 허용
```
#### 2.2 약결합(loosely coupled) 시스템

![](2022-07-29-19-12-54-image.png)
운영체제, 메모리, 프로세서, 입출력 장치 등이 독립된 시스템들이 통신을 통해 메시지 전달, 원격 저 호출로 통신.
➕ 시스템 하나가 고장나도 다른 독립된 시스템에 장애가 영향을 미치지 않음
### 3 네트워크의 구조(topology)
네트워크의 노드나 링크 요소를 물리적으로 연결하는 방법들
```ad-note
title: 노드(Node)
사이트, 터미널, 컴퓨터 등 통신하는 객체를 의미
```
#### 3.1 망(mesh) 구조
각 노드를 시스템의 모든 노드와 직접 연결하는 완전 연결(fully connected) 방법
![](2022-07-29-19-13-06-image.png)
➕ 두 노드를 직접 연결하므로 매우 빠름
➕ 시스템 분할에 필요한 장애의 수가 많음 = 신뢰성이 높음
➖ 노드가 많을 수록 기하 급수적으로 설치 비용이 많이 들고, 통신선 낭비가 많음.
#### 3.2 트리(tree) 구조, 계층(hierachy) 구조
주로 회사 등에서 사용하는 방법, 네트워크의 각 노드가 트리 형태로 구성됨.
![](2022-07-29-19-13-25-image.png)
➕ 기본 비용이 망 구조보다 낮음
➖ 부모 노드가 고장나면 그 아래 모든 자손 노드들은 자신들을 제외한 다른 노드들과 고립됨
#### 3.3 성형(star) 구조
모든 노드를 중앙 노드에 직접 연결하고, 중앙 노드 외의 다른 노드는 서로 연결하지 않음.
![](2022-07-29-19-13-39-image.png)
그림 11-5 중앙의 모든 노드의 연결을 중계하는 노드를 중앙 노드라고 하며, 메시지 교환을 담당.
➕ 기본 비용이 노드 수에 비례하고 비교적 저렴
➕ 비교적 간단한 구조로, 집중 제어 및 유지 보수 수월
➖ 중앙 노드에 병목 현상에 의한 성능 감소
➖ 중앙 노드 장애 발생 시 전체 시스템 마비
#### 3.4 링(ring) 구조
각 노드를 정확히 다른 노드 2개와 연결하는 방법
![](2022-07-29-19-19-11-image.png)
단 방향 구조와 양 방향 구조가 있다.
단방향 구조는 한 노드나 링크가 고장 나면 네트워크 분할
양 방향 구조는 연결이 2개 고장 나면 네트워크 분할
➕ 기본 비용이 저렴한 편이고, 노드 수에 비례함
➖ 메시지가 링을 순환하면서 성능 저하
#### 3.5 버스(bus) 구조
연결 버스(중앙 통신 회선) 하나에 모든 노드를 연결하는 방법
![](2022-07-29-19-19-29-image.png)
➕ 기본 비용이 노드 수에 비례하고 경제적
➕ 각 노드의 고장이 노드 간 통신에 영향을 주지 않음, 신뢰성 높음
➕ 노드의 추가 변경 제거 등이 비교적 쉬움
➖ 버스에 장애가 발생하면 네트워크 전체에 영향을 미침
### 4 원격 프로시저(RPC, Remote Procedure Call) 호출
분산 시스템에서 한 컴퓨터에서 실행할 프로세스를 다른 컴퓨터에서실행하는 프로세스의 프로시저(함수)를 호출하는 방법.
클라이언트/서버 모델이 전제.
주로, 원격지 노드에 필요한 데이터가 있을 때 요청하는 방법으로 사용한다.
![](2022-07-29-19-19-42-image.png)
**간단한 클라이언트 서버 간 RPC 원리**
1. 클라이언트와 서버 사이에 프로시저를 호출하는 프로그램을 허용하여 지역 프로시저를 호출
2. 잠시 클라이언트의 프로시저를 멈추고 네트워크를 통해 지역적으로 분산된 원격 프로시저를 실행
3. 반환 값을 네트워크 통신 응답을 통해 클라이언트로 받는다.
![](2022-07-29-19-20-13-image.png)
**스터브(stub)**
- 데이터를 전송하려고 다양한 형태의 데이터로 서로 변환하는 기능을 수행하는 모듈
➕ 프로세스들이 원격 컴퓨터에 있는 프로시저를 지역 컴퓨터에 있는 프로시저 처럼 쉽게 호출하여 상호 운용성 증진
➖ 통신의 신뢰성과 보안, 전역변수의 미지원
### 5 분산 시스템의 구조와 구축 목적
분산 시스템은 네트워크로 연결된 여러 노드, 즉 개인 메모리와 클록이 없는 프로세서들의 집합을 이용해 프로그램 하나를 분산하여 실행해 서로 정보를 교환하는 구조이다.
![](2022-07-29-19-20-27-image.png)
분산 시스템은 다음과 같은 목적으로 구축한다.
- **자원 공유 용이** : 분산 시스템으로 다른 노드의 자원, 장치, 데이터, 함수에 접근할 수 있다.
- **연산 속도 향상** 
	- 특정 연산을 동시 수행 가능한 여러 연산으로 분할해 여러 노드에서 동시에 수행하여 성능 향상
	- 특정 노드가 너무 작업이 집중되면 다른 노드로 작업 이동(부하 분담, load sharing) 
- **신뢰성 향상**
	- 한 노드가 고장 나도 나머지 노드가 계속 작동하여 신뢰성 보장
	- 시스템이 고장을 감지하고 복구하는 작업 수행
- **통신 기능**
	- 다수의 노드를 통신 네트워크를 이용해 연결하면 다른 노드에 있는 사용자들이 정보를 교환 

분산 시스템은 다음과 같은 투명성(transparency)을 보장해야 한다. 일종의 성능 지표?

다만, 모든 투명성을 실현하는 것은 복잡하고 비용이 많이 들므로, 각 응용 시스템 마다 필요한 투명성만 구현한다.

- **액세스 투명성(access transparency)** : 프로세스가 다른 노드의 차이(컴퓨터 구조, 운영체제 등)과 관계없이 동일한 형식으로 액세스할 수 있게 하는 능력
	- SQL 쿼리, 웹 내비게이션 등
- **위치 투명성(location transparency)** : 자원 위치와 각 컴포넌트가 상호작용는 위치를 사용자가 몰라도 지역 파일처럼 액세스 가능
	- 웹페이지, NFS(Network File System, 네트워크 파일 시스템)
- **고장 투명성(failure transparency)** : 시스템 구성 요소(컴포넌트)와 통신 오류 때문에 시스템을 수행하는 데 장애를 받지 않도록 하며, 이를 빠르게 복제나 복구할 수 있도록 함.
	- 보통 고장의 여파를 성능 감소 정도로만 느끼게 만든다.
	- 데이터베이스 관리 시스템(database management system)
- **중복 투명성(replication transparency)** : 복제한 자원 그룹에서 모든 액세스가 자원이 하나만 있는 것처럼 보이게 해 신뢰성과 유용성을 높일 수 있음
	- 분산 DBMS, 웹페이지 미러링(mirroring)
- **이동 투명성(migration transparency)** : 자원을 한 시스템에서 다른 시스템로 이동해도 사용자는 의식하지 않고 사용 가능
	- 웹페이지, NFS
- **영속 투명성(permanence transparency)** : 자원이 저장된 위치 정보를 감춤.
- **자원 투명성(resource transparency)** : 구성 요소에서 자원의 배당과 해제 정를 감춤.
- **트랜잭션 투명성(transaction transparency)** : 공유 공간에서 동작하는 트랜션 연산 조정과 자원 집합 사이의 결합을 숨겨 데이터 무결성과 일관성 확보
- **재배치 투명성(reassignment transparency)** : 한 객체의 재배치를 이와 통신하는 다른 객체에 감출 수 있게 함.
- **규모 투명성(scale transparency)** : 구성 요소를 추가하거나 제거하는 등, 규모가 바뀌어도 사용하자가 의식하지 않음
- **병행 투명성(concurrency transparency)** : 사용자와 응용 프로그램이 서로 간섭 없이 공유 데이터 또는 객체에 동시에 액세스 가능.
	- NFS, 금융 자동화 기기(ATM) 네트워크
## 02 네트워크 운영체제
네트워크 운영체제는 단일 사용자 환경인 네트워크 운영체제와 시스템에 연결된 컴퓨터들의 원격 자원을 공유하기 위한 분산 운영체제로 구분
### 1 네트워크 운영체제(NOS, Network Operating System)
#### 1.1 네트워크 운영체제의 원리
네트워크 운영체제는 메모리 관리, 프로세서 관리, 장치 파일 관리 등 전역 제를 수행하지 않고 네트워크에 있는 서버를 사용하도록 지원하여, 자율적인 컴퓨터들이 편리하고 효율적인 방법으로 서로를 이용할 수 있도록 하는 분산 시스템 소프트웨어이다.

네트워크 운영체제는 통신을 제어하고 분산된 자원을 공유하며 독립된 시스템을 서로 연결하기 위해 개발됨.
![](2022-07-29-19-20-52-image.png)
그림 11-11처럼 네트워크 운영체제는 서버에 저장된 대용량 파일이나 서버에 연결된 공유 프린터 등 자원을 요청한 클라이언트에 제공하려고 설계함.

일반적인 운영체제와의 차이점은 컴퓨터 한대 뿐만 아니라 LAN(근거리 통신망, Local Area Network)의 전체 자원을 관리하여 클라이언트가 서버와 상호작용할 수 있도록 도와준다.

![](2022-07-29-19-21-13-image.png)

#### 1.2 네트워크 운영체제의 주요 기능
네트워크 운영체제는
- 네트워크 사용자마다 동질성이 부족하므로 가능하면 표준을 유지하며 모든 컴퓨터를 지원하도록 새로운 기술을 용이하게 적용할 수 있는 구조이어야 함.
- 프린터나 파일 관리는 물론 네트워크 전체를 항상 관리, 감시하면서 장애가 발생하면 복구도 수행할 수 있는 환경을 보장해야 함.
- 다수의 네트워크 클라이언트가 신속하게 데이터에 액세스 할 수 있도록 효율적이고 신뢰성 있어야 한다.

주요 기능들은 다음과 같다.
- **자원 공유** : 네트워크에 연결된 서버와 클라이언트 간에 하드디스크나 프린터 등 자원 공유 가능
- **액세스 권한 부여** : 사용자는 원격 사이트의 자원을 사용할 수 있도록 액세스 가능.
- **파일 전송** : 한 컴퓨터에서 다른 컴퓨터로 데이터를 전송
- **데이터 보호** : 사용자 별 적합한 권한(읽기 권한, 쓰기 권한 등)을 설정하고 데이터를 관리, 보호
- **관리 제어** : 각 클라이언트의 네트워크 이용 정보와 네트워크에서 발생하는 여러 문제를 해결하고 조절,관리하는 기능 제공
#### 1.3 네트워크 운영체제의 운영 방법
네트워크 운영체제는 크게 P2P(peer-to-peer) 모델과 클라이언트/서버 모델로  구분
![](2022-07-29-19-21-31-image.png)
**P2P 방법**
그림 11-14와 같이 동등하게 작동되는 LAN에 연결된 각 컴퓨터가 상황에 따라 클라이언트, 서버로 동작한다.
즉 파일 서버나 중앙 집중식 관리 자원이 없으며, 모든 컴퓨터가 동일한 액세스 권한과 네트워크에 있는 사용 가능한 자원에 같은 권한을 가짐.
➕ 적은 초기 비용: 클라이언트/서버의 기능을 같은 컴퓨터에 구현
➕ 자원 : 자원의 활용 극대화와 자원을 각각 균일하게 공유
➖ 분산 : 파일과 응용 프로그램에 중앙 저장소 없이 분산되므로 관리 힘듦.
➖ 보안 : 서버와 클라이언트에 보안 적용 힘듦
![](2022-07-29-19-21-46-image.png)
**클라이언트/서버 방법**
네트워크에 연결된 컴퓨터가 각각 클라이언트나 서버로서 역할을 수행하는 방법.
- 서버 : 작업을 수행하는 시스템, 프린터 서버, 파일 서버 등의 서비스 제공
- 클라이언트: 서비스를 요청하는 시스템, 워크스테이션 모델의 경우 클라이언트는 예외적으로 동시에 한명만 사용 가능

![](2022-07-29-19-22-06-image.png)
그림 11-15처럼 네트워크와 독립적이며, 네트워크에 접속하지 않은 컴퓨터 시스템은 자신의 환경에 맞게 변경, 관리할 수 있음.

➕ 중앙 집중식: 서버에서 자원과 데이터 보안 제어
➕ 유연성 : 새로운 기술을 시스템에 쉽게 통합
➕ 접근성 : 서버를 여러 플랫폼이나 원격으로 액세스
➖ 비용 : 전용 서버에 초기 투자가 필요
➖ 소프트웨어 : 네트워크 운영체제 소프트웨어가 필요
➖ 의존성 : 서버가 다운되면 네트워크가 작업을 중지
➖ 유지 관리 : 대형 네트워크 작업을 효율적으로 동작할 수 있는 관리자 필요

### 2 분산 운영체제(DOS, Distributed Operating System)의 연산
분산된 컴퓨터 간에 자원을 쉽게 공유하고 액세스할 수 있는 운영체제

네트워크 운영체제의 지역적임을 극복하기 위고 전역적으로 제어 관리하기 위해 발전됨.
![](2022-07-29-19-22-17-image.png)
다음과 같은 기능을 수행한다.
- **데이터 이동(data migration)**
	사용자가 데이터를 요청하면 이를 전송하는 방법은 크게 두 가지가 있다.
	- 파일 전체를 요청자에게 보내는 방법, 이후 수정 여부와 관계없이 요청자는 원 데이터 보유자에게 파일을 되돌려 보내야 한다.
	- 작업에 필요한 부분만 요청자에게 보내는 방법, 이후, 수정된 부분만 원 데이터 보유자에게 되돌려 보낸다.
	주로 전체 파일을 액세스해야 한다면 첫번째, 일부분만 접근해도 되면 두번째가 효율적
- **연산 이동(computation migration)**
	사용자가 함수나 연산을 요청하여 그 결과 값을 받는 방법.
	동시 수행이 가능하여 이쪽이 더욱 효율적일 때가 많다.
- **프로세스 이동(process migration)**
	프로세스 전체를 이동시켜 실행하는 방법
	다음과 같이 두가지 방법으로 분류한다.
	- 사용자에게 프로세스 이동 사실을 숨김
		➕ 사용자가 이동을 위한 외부 명령을 코딩할 필요 없음
		➕ 부하 균등화와 연산 속도 상승 효과
	- 사용자가 직접 이동 방법을 명시하거나 허가하게 함
		➕ 효율적인 하드웨어나 소프트웨어 이용 가능
	프로세스 이동은 다음의 장점이 존재한다.
	➕ **부하 균등화** : 프로세스는 네트워크로 작업량을 분산
	➕ **연산 속도 향상** : 다른 사이트에서 동시에 수행 가능한 여러 서브 프로세스로 나눈다면 전체 프로세스의 반환 시간이 줄어듦
	➕ **하드웨어 이익** : 예를 들면 행렬 계산 등은 특화된 배열 프로세서에 맡기는 게 좋다.
	➕ **소프트웨어 이익** : 소프트웨어 규모가 너무 크거나 보안, 인증 등의 이유로 연산 이동이 불가한 경우

### 3 분산 운영체제의 구현
분산 운영체제는 대부분 마이크로 커널 기반 구조이다.

프로세스와 스레드 관리, 메모리 관리, 프로세스 간 통신, 장치 관리와 시스템 인터럽트 처리 등의 기본적인 기능만 유지하며, 나머지는 응용 프로세스로 처리한다. 

크게 프로세스 기반과 객체 기반으로 나눠서 구현한다.

- **프로세스 기반 분산 운영체제**
	- 시스템의 모든 프로세스와  자원을 시스템 서비스를 제공하는 프로세스의 집합으로 해석.
	- 프로세스 간 동기화와 시스템 상태, 사용자 프로세스의 제어, 프로세스 생성과 스케줄링, 인터럽트 등 프로세스 관리는 프로세스 간에 메시지를 교환해 수행
- **객체 기반 분산 운영체제**
	- 시스템의 각 하드웨어와 소프트웨어들을 독립된 객체로 해석
	- 각 객체에는 고유한 이름과 식별자, 상태가 있으며, 객체의 생성, 제거 등을 커널이 관리한다.
### 4 분산 시스템에서 프로세스 관리
분산 시스템 교착 상태는 복잡한 문제를 일으킨다.
교착 상태는 자원 할당 교착 상태와 통신 교착 상태로 구분할 수 있다.
#### 4.1 자원 할당 교착 상태
프로세스가 서버에 있는 데이터 객체나 입출력 자원에 액세스하려 할 때, 이미 다른 프로세스에 할당된 자원을 요구하면 발생

교착 상태는 다음 네 가지 조건이 모두 성립할 때 발생한다.(교착 상태 단원 참조)
- 상호 배제
- 점유와 대기
- 비선점
- 순환 대기
따라서 이 중 하나만 방지 돼도 교착 상태가 생기지 않는다.

다음은 이러한 조건을 방지하는 방법들이다.

**교착 상태 예방**
- 자원의 종류에 따라 선행적인 순서를 정의하면 순환 대기 조건이 예방 된다.
	- 예를 들어 B 자원은 무조건 A 자원을 먼저 이용한 뒤 얻을 수 있다면, B 자원을 이용하고 있는 프로세스는 A 자원을 이미 사용해 다시 요구할 리 없으니, A자원을 가진 프로세스가 B자원을 요구하고, B 자원을 가진 프로세스가 A 자원을 요구하는 순환 대기가 일어나지 않는다.
- 작업 수행 전에 필요한 모든 자원을 모두 확보 가능할 때만 할당 받게 한다면 
점유와 대기 조건이 예방 된다.

**교착 상태 탐지**
- 시스템에서 모든 자원의 점유와 요구 사항을 자원 그래프로 표현해 사이클 여부를 검사, 이후 프로세서가 실행에 필요한 자원 확보 시까지 실행을 지연시킨다.
- 다음과 같은 방법들로 교착 상태 탐지 가능
	- 중앙 집중형 제어 : 노드 하나가 교착 상태 탐지 전담, 모든 요구와 해제 메가 중앙 노드로 전송되어 파악.
		➕ 구현하기 쉬움
		➕비교적 작고 통신 속도가 높은 LAN에 효율적
		➖ 자원 요청이 중앙 프로세서에 집중되어 병목 현상 발생
		➖ 중앙 프로세스 문제 시 시스템 마비
	- 계층형 제어 : 노드를 계층 구조로 구성하고 한 노드가 루트 역할을 담당하게 한 후 자원 할당 정보를 수집해 교착 상태 탐지, 중앙 집중형 제어와 비슷
	- 분산형 제어 : 모든 프로세스가 협력해 교착 상태 탐지
		➕ 노드 장애 발생에 대한 장애 내구성 높음
		➖ 정보 교환에 의한 오버헤드 발생

**교착 상태 회피**
자원 할당 요구 허용 뒤, 교착 상태 여부를 결정하여 판단
➖ 모든 노드가 시스템 전역 상태를 파악 및 유지를 위한 오버헤드가 심함
➖ 안전 상태를 검사하는 것도 상당한 처리 오버헤드 발생
따라서 구현이 어렵다.

**교착 상태 복구**
다른 프로세스에 필요한 자원을 많이 사용하는 프로세스를 선택하여 제거한 후 다시 처음부터 재실행 하도록 조치

#### 4.2 메시지 전송 교착 상태
프로세스가 메시지를 기다리는 상태

다음과 같은 두 가지 이유로 발생한다.

**상호 대기**
동일한 그룹에서 한 프로세스가 다른 프로세스가 보낸 메시지를 기다리고 있고 전송 중인 메시지가 없을 때 발생

![](2022-07-29-19-22-38-image.png)

그림 11-17은 시스템 교착 상태를 WFG(wait for graph)로 표현한 것이다.
그림 (a)는 교착 상태가 아니며, 그림 (b)는 상호 대기에 의한 교착 상태이다.

**메시지 할당 버퍼 불충분**

그림 11-18은 메시지 할당 버퍼 불충분에 의한 교착 상태 예시이다.
(a)는 서로의 버퍼가 가득 차 패킷을 전송하거나 수신할 수 없는 상태로, **메시지 직접 저장-전송 교착 상태**라고 한다.
(b)는 어떤 노드의 버퍼가 패킷로 가득 차 메시지를 수신할 수 없어, 버퍼를 비우지 못하게 되어 순환 대기 상에 빠진 상태로 **메시지 간접 저장-전송 교착 상태**라고 한다. 

![](2022-07-29-19-22-59-image.png)

이러한 교착 상태는 
- 각 링크 별로 별도의 버퍼를 하나씩 사용하게 하여 예방
- 버퍼가 가득차지 않게 전송 메시지 수에 상한 값을 부여하여 예방
- 계층화된 버퍼 풀(pool)을 이용해 교착 상태 제거
	- 버퍼가 부족 시 버퍼 풀에서 가져오도록 하여 버퍼가 꽉 차지않게 예방

### 5 클라이언트/서버 분산 컴퓨팅
#### 5.1 클라이언트/서버 시스템의 정의
클라이언트 역할과 서버 역할을 하는 프로그램을 나누어 구성하는 시스템 
- 클라이언트 : 다른 프로그램에 서비스를 요청하는 프로그램, GUI, 입출력, 요청 등을 담당(웹 브라우저(크롬))
- 서버 : 그 요청에 응답하는 프로그램, 데이터 저장, 처리, 제공을 담당(웹서버(IIS, APache))

![](2022-07-29-19-23-14-image.png)

클라이언트 서버 분산 컴퓨팅 환경은 사용자, 응용 프로그램, 자원들을 네트워크(단일 LAN이나 WAN)으로 연결함.

```ad-note
title: WAN(Wide Area Network, 광역 네트워크)?

지역적으로 넓게 분산된 네트워크 시스템, 통신 링크가 비교적 느리고 신뢰성이 낮음. 전화선, 통신위성 채널 등이 예시
```

![](2022-07-29-19-23-29-image.png)

➕사용자에게 편리한 인터페이스와 응용 프로그램 제공
➕ 데이터베이스, 네트워크 관리, 유틸리티 기능의 중앙 집중화로 유지 부담 감소
➕데이터와 정보에 액세스 하는데 필요한 컴퓨터와 인터페이스 유형 선택이 자유로움
➕ 여러 지역에 걸쳐 분산된 프로그램을 서로 연결시키기 편리함

#### 5.2 2계층의 일반적인 클라이언트/서버 구조
클라이언트는 원활한 상호작용을 위해 GUI 사용자 인터페이스 설계가 매우 중요하다. 이러한 역할을 프레젠테이션 서비스라고도 한다.

![](2022-07-29-19-23-46-image.png)

2계층 구조는 그림 11-21과 같다.

클라이언트와 서버가 물리적으로 독립된 시스템에 존재하며, 운영체제, 플랫폼 등이 서로 다를 수 있다. 이를 통해 공유 자원과 작업을 분할 할 수 있다.

이 둘을 서로 연동하기 위해 TCP/IP나 OSI 참조 모델 같은 통신 소프트웨어와 분산 응용 프로그램을 이용하여 연동한다.

```ad-note
title: OSI? TCP/IP?

OSI(Open System Interconnection reference model)
- 이기종 시스템간 네트워크 연결을 위해 네트워크를 계층 7개로 나눠 네트워크 를 이용해 응용 프로그램 정보를 다른 컴퓨터의 응용 프로그램에 전달하는 방법 설 명

TCP/IP(Transmission Control Prtocol/Internet Protocol)
- 가장 널리 사용되는 네트워크 계층 프로토콜
```

![](2022-07-29-19-24-04-image.png)
복잡한 계산이나 유형이 다른 데이터를 분석하는 소프트웨어 위치에 따라 팻 클라이언트와 씬 클라이언트로 구분한다.

- **팻(fat) 클라이언트**
주요 응용 프로그램 처리 모듈과 프레젠테이션 로직이 클라이언트에 위치
그림 11-22의 (a)에 해당한다. 

- **씬(thin) 클라이언트**
주요 응용 프로그램 처리 모듈과 데이터베이스가 서버에 위치하고, 클라이언트는 프레젠테이션 로직만 수행
즉, 클라이언트는 사용자 인터페이스와 메시지 전달만 담당하는 가벼운 역할이다.
그림 11-22의 (b)에 해당

2계층 모델의 장단점은 다음과 같다.

➕ 서로 다른 환경의 클라이언트와 서버를 연동 가능

➖ 네트워크 통신량 증가로 인한 병목 현상 발생
	- 캐시 등으로 완화 가능하나, 캐시의 일관성 문제 발생
➖ 응용 프로그램의 논리적 구조나 물리적 구조가 완전히 분리되지 않아, 프로세스나 업무 환경 변경 시, 소프트웨어 수정이 힘들다.

➖ 대부분 응용 프로그램이 특정 데이터베이스에 종속되어 응용 프로그램, 데이터 통합이 힘들고 유연성이 떨어짐 (확장성 한계)

➖ 이식성 한계로 다른 서버로 프로그램 기능 일부 이동시키기 어려움

#### 5.3 3계층의 클라이언트/서버 구조
데이터베이스가 위치한 서버 부분과 사용자가 주로 사용하는 클라이언트를 완전히 분리하고, 응용 프로그램 로직을 모듈화해서 중간 계층에 별도로 두어 유연하고 확장 가능하게  한 3 계층의 클라이언트/서버 구조 시스템

클라이언트 증가에 따른 성능 저하 문제를 해결하기 위해 서버에 중재 소프트웨어인 미들웨어를 적용.

**미들웨어의 역할 예시**
- 서버의 부하를 균등하게 분배하는 부하 분산(로드 밸런싱, load balancing)이 가능
- 응용 프로그램 로직을 분산시키는 모듈화해서 중간 계층에 두어 분산 환경에서 일관성있게 액세스 가능
- 클라이언트의 데이터 가공 작업을 맡음 -> 클라이언트 요구에 따라 데이터 관리 서버와 연동해 클라이언트의 요구를 처리 후 결과 전달 

위와 같은 역할을 통해서 클라이언트와 서버 기능을 분리해 비대해지는 것을 막음.

![](2022-07-29-19-24-17-image.png)

➕ 파일 캐시의 일관성과 장치 간의 환경 불일치를 극복해줌.
➕ 서버 확장에 용이, 사용자 수 급증 시 부하 분산 및 추가 확장으로 일정한 응답 시간 보장
➕ 서버, 클라이언트의 작업 처리 부담을 덜고, 여러 기능을 제공하여 시스템 성능과 융통성이 향상
➕ 응용 프로그램 로직을 모듈화하여 유지 관리 쉬움

#### 5.4 클라이언트/서버 구조와 미들웨어

미들웨어(middleware)는 
- 클라이언트/서버 사이에 교량 역할

![](2022-07-29-19-24-29-image.png)

- 다른 환경에서 실행되는 응용 프로그램이 상호 원만하게 통신하게 함.
- 모든 플랫폼으로 시스템 자원에 액세스할 수 있게 하는 소프트웨어
- 서로 다른 시스템 간에 상호 운영을 하는 데 필요한 소프트웨어
- 네트워크가 연결된 분산 컴퓨팅 환경에서 사용자 컴퓨터와 네트워크에서 실행되는 응용 프로그램 간에 자유롭게 데이터를 이동하여 응용 프로그램 개발을 지원하는 소프트웨어

주로 운영체제와 분산 응용 프로그램 사이에 존재한다.

미들웨어는 데이터베이스 엔진과 클라이언트를 연결하여 호환성을 제공하기도 하고, GUI, 각종 통신 소프트웨어 역할을 하기도 한다.
이외에도 그림 11-26처럼 개발 도구, 실행 환경, 관리 도구 등으로 구성되며, 통신 서비스, 코어 서비스, 응용 프로그램 서비스로 나뉜다.

![](2022-07-29-19-24-42-image.png)

## 03 다중 처리 운영체제
### 1 다중 처리(multiprocessing) 시스템의 구조와 원리
다중 처리 혹은 병렬 처리는 다수의 프로세서를 동시에 수행하여 시스템 성능을 향상 시키는 방법이다.

다중 프로그래밍은 소프트웨어 관점, 다중 처리는 하드웨어 관점

**병렬 프로그래밍의 어려움**
많은 프로세스를 통한 병렬 연산을 통해 처리량을 늘릴 수 있으나, 다음과 같은 이유로 병렬 프로그래밍은 힘들다.
- 인간의 사고는 병렬적으로 생각하기 어려움
- 인간의 언어는 병렬성으로 적절히 표현하지 못한다.
- 다중 처리는 병렬성을 통한 성능 향상을 염두에 두고 만들지 않고, 다중 사용자를 위해 만들었으므로, 병렬성 경험이 부족함.
- 컴퓨터 하드웨어는 순차적 처리에 익숙함
- 병렬 프로그램은 오류를 검색하기 어렵고, 정확성 증명 방법이 복잡하다.

**병렬 프로그래밍의 장점**
- 많은 프로세서를 이용해 신뢰성 증가
- 가용성 증가 : 프로세서가 고장나면 성능이 조금 줄어들 뿐 시스템 사용 가능
	- 시스템이 고장난 프로세서를 파악하고, 다른 프로세서에게 일을 맡김
	- 시스템이 고장이 나지 않도록 자원 할당 방법과 부담을 분배
- 컴퓨터 성능의 증가
- 비교적 저비용으로 단일 프로세서 컴퓨터 시스템의 계산 능력을 높일 수 있음

![](2022-07-29-19-25-00-image.png)
**다중 처리 시스템의 특징**
- 다중 처리 시스템은 성능이 거의 비슷한 2개 이상의 프로세서를 포함
- 모든 프로세서는 동일한 메모리를 공동으로 사용
- 모든 프로세서는 입출력 채널과 제어 장치, 그 외의 장치들을 공동으로 사용
- 전체 시스템은 하나의 운영체제로 운영, 해당 운영체제는 각 프로세스, 데이터들의 상호작용을 도움

### 2 다중 처리 시스템의 연결 방법
다중 처리 시스템은 다양한 방법으로 연결할 수 있다.
#### 2.1 공동 버스(common bus) 시스템
그림 11-28과 같이 프로세서, 메모리, 입출력 장치 등 각종 장치 간에 하나의 공동 버스를 제공하는 방법
- **공동 버스** : 각종 장치 간 정보 전송을 장치의 버스 인터페이스를 통해 제어하는 수동 장치

![](2022-07-29-19-25-15-image.png)

**버스를 통한 데이터 통신 방법**
데이터 전송을 원하는 프로세서와 상대방 장치를 사용할 수 있는지 검사하고, 상대방 장치에 데이터 처리 방법을 알린 후 데이터를 전송

**제어 신호 인식 방법**
데이터를 전송 받는 장치는 버스에 실린 메시지가 자신에게 오는 정보라는 것을 알기 위해 전송 장치의 제어 신호들을 다음과 같은 방법으로 인식
- **어드레싱** : 버스에서 모듈을 구분해 데이터 목적지 결정
- **중재** : 모든 입출력 모듈은 일시적으로 마스터 기능 수행, 버스 제어는 우선순위 방법을 사용해 경쟁적 요청을 중재하는 데 제공
- **시간 공유** : 하나의 모듈이 버스를 제어할 때 다른 모듈은 잠김 및 버스 액세스를 달성할 때까지 작업을 일시 중단

➕ 버스에 장치를 추가하여 손쉽게 장치 연결 가능
➕ 경제적임
➕ 융통성 있음
➕ 구조가 간단함

➖ 버스에 이상이 생기면 전체 시스템 불능
➖ 시스템의 전체 전송량이 버스 전송률에 따라 제한
➖ 시스템이 바빠지면 버스 경쟁에 의한 성능 감소
➖ 따라서 작은 규모의 시스템에만 사용
#### 2.2 크로스바 교환 행렬(crossbar switch matrix) 시스템
그림 11-29처럼 메모리와 프로세서의 수만큼 공동 버스 시스템의 버스 수를 켜 격자 모양으로 크로스 스위치 포인트를 지정하는 방식이다.
- 크로스 스위치 포인트: 프로세서의 경로를 결정하는 메모리 모듈

![](2022-07-29-19-34-48-image.png)

➕ 메모리마다 회선이 달라 서로 다른 메모리 2개를 동시에 참조하며, 충돌이 없음
➕ 각종 장치의 인터페이스를 간단하게 할 수 있음
➕ 전송 경로의 경우의 수가 여러 개라 전체 전송률이 매우 높음
➕ 장치를 추가하여 단위 시간 당 처리량을 더욱 높일 수 있음
➕ 추가 논리 회로를 두어 신뢰도를 높이고 시스템 분할이 가능

➖하드웨어, 교환기가 복잡해질 수 있음

#### 2.3 다중 포트 메모리(multiport storage) 시스템
그림 11-30과 같이 제어 논리회로, 교환 논리회로, 우선순위 조절 논리회로를 각 메모리 인터페이스에 설치하여 포트를 이용해 메모리를 할당하고, 장치가 메모리를 할당하는 방식이다. 
![](2022-07-29-19-25-26-image.png)
**다중 포트 메모리 시스템 메모리 접근 충돌 방지 대책**
- 메모리 포트에 영구적인 우선순위를 할당해 동시에 메모리에 접근 시 우선순위 순으로 할당
- 그림 11-31 처럼 적은 수의 프로세서와 입출력 프로세서만 메모리에 접근하도록 함

![](2022-07-29-19-34-22-image.png)

➕ 프로세서와 메모리 사이의 다중 경로로 높은 전송 속도를 얻을 수 있음
➕ 프로세서 메모리 할당 확보가 쉬워 높은 안정성

➖ 비싼 메모리 제어 논리와 케이블, 커넥터의 수가 필요

#### 2.4 하이퍼큐브(hypercube) 시스템
N개의 주소로 프로세서 $2^n$개로 인접한 다른 프로세서와 큐브 모양의 연결하여 할당하는 약결합 시스템

![](2022-07-29-19-33-59-image.png)

주소의 길이가 1이면 2개의 프로세서, 주소의 길이가 2이면 4개의 프로세서, 주소의 길이가 3이면 8개의 프로세서를 상호 연결한다.

### 3 다중 처리 시스템의 운영체제
#### 3.1 주종(master/slave) 운영체제
그림 11-33 같이 프로세서 하나를 주(M, 마스터)로 지정해 운영체제를 실행하고, 나머지 프로세서는 사용자 수준의 프로그램을 실행할 수 있는 종(S)으로 지정하는 구현하기 쉬운 구조
- 주 프로세서는 범용 프로세서로 연산 뿐만 아니라 입출력도 담당
- 종 프로세서는 연산만 담당

![](2022-07-29-19-27-05-image.png)

만약 종 프로세서가 운영체제에 개입할 필요가 있다면 인터럽트를 보내고, 주 프로세서가 해당 인터럽트를 처리함

이때 한 순간에 하나의 인터럽트만 처리하므로, 
➕ 상호 배제 문제가 간단해짐
➖ 대기 큐가 생겨 프로세스 활용도와 응답 시간에 영향
- 따라서 시스템 부하가 잘 알려져 있어 스케줄링이 쉬운 경우에 유리
- 특히 입출력이 많은 작업은 주 프로세서만 가능하므로 부담 균형이 불균형

➖ 또한, 주 프로세서가 고장 나면 모든 시스템이 사용 불가(낮은 신뢰성)
- 주 프로세서가 압도적으로 성능이 좋은 비대칭적 시스템에 적당

➖ 하드웨어 비대칭성 : 프로세서들이 동등하지 못하여 하드웨어 최적으로 사용 불가

#### 3.2 분리 실행
각 프로세서마다 운영체제가 서로 다르며, 각 프로세서에서 발생하는 인터럽트는 해당 프로세서에서 해결하는 구성 방법

물론, 전체 시스템을 위한 정보는 상호 배제를 이용해 접근한다.

![](2022-07-29-19-27-18-image.png)

➕ 공동 테이블 경쟁 적음
➕ 주 프로세서가 없으므로, 신뢰성이 높음

➖ 전체 프로세서를 감시하는 프로세서가 없으므로 고장 탐지 및 복구가 힘듦
➖ 입출력 장치는 수동으로 재구성 필요
➖ 한 프로세서가 바빠도 다른 프로세서로 부하 분배 불가능

#### 3.3 대칭

여러 프로세서가 하나의 운영체제를 공유하는 방식, 모든 프로세서가 동등한 에 있으며, 공유 운영체제가 모든 프로세서와 입출력 장치, 기억 장치를 사용할 수 있도록 관리.

운영체제 동시 진입을 방지하기 위해 재진입 코드와 상호 배제 필요

여러 프로세서가 하나의 작업을 협력할 수 있음
-> 이를 위해 시스템 테이블과 시스템 기능을 책임지는 운영 프로세서를 하나 지정
-> 통일성 있고 일관성 있게 운영할 수 있다. 

![](2022-07-29-19-27-32-image.png)

➕ 작업 부하를 가장 효과적으로 분산, 다른 프로세서로 작업 이전 가능
➕ 신뢰성이 가장 높음
- **신뢰성 구축 방법**
	한 프로세서가 고장 나면 운영체제는 그 프로세서를 제거하고, 이 사실을 오퍼레이터에 알림 
➕ 프로세서들의 병행 작업 가능, 자원을 더욱 효율적으로 활용

➖ 구축이 복잡하고 높은 기술 요구
➖ 협업 시, 동시에 여러 프로세서가 운영 프로세서가 될 시, 성능 저하
- 이를 막기 위해 시스템 데이터를 여러 독립적인 프로세서에 분산 수용한 뒤, 개별적으로 폐쇄할 수 있게 한다.

### 4 클러스터(cluster)
클러스터는 사용 목적에 따라 고성능, 부하분산, 고가용성 클러스터로 구분

#### 4.1 클러스터의 구조
컴퓨터 여러 대를 연결하여 단일 컴퓨터처럼 동작하도록 한다. 
대칭형 다중 처리가 가능하며, 클러스터를 구성하는 노드는 단일 시스템, PC, SMP, 프로세서 등이 될 수 있으며, 물리적으로 분리되어 있으며 LAN으로 연결되어 있다.

![](2022-07-29-19-27-46-image.png)

시스템 전반을 위한 서비스 (예를 들어 백업과 사용자 관리, 고장 탐지 복구, 네
트워크 감시, 단일 시스템 관리 등)가 필요
-> 클러스터 시스템 소프트웨어를 제공해야 하며, 이를 연결하는 서버가 필요

**클러스터 내부의 통신**

네트워크 인터페이스 하드웨어는 통신 프로세서처럼 작동하며 클러스터 노드 간의 데이터 패킷을 전송, 수신하게 함.

통신 소프트웨어는 빠르고 신뢰성 있게 통신하게 해주는 액티브 메시지 등을 사용
- **액티브 메시지(active message)** : 병렬 분산 시스템에서 널리 사용하는 메시지 기반 통신 시스템
	- 메시지 핸들러를 내용과 함께 포함해 전송하여, 도착하자마자 핸들러가 메시지 처리
	- 이를 통해 버퍼링 중의 오버헤드가 줄어들며, 비동기적 수행으로 병렬화 가능
	
외부에서 해당 클러스터 네트워크와의 통신을 위해 공인 IP를 사용하며, 내부의 클러스터 간의 통신은 사설 IP를 이용함

클러스터 미들웨어는 사용자가 통합된 하나의 시스템으로 인식하도록 SSI(single system image) 기능을 이용한다.

#### 4.2 고성능 클러스터(HPC, High-Performance Clusters)

대규모 연산을 계산하는 데 사용하는 가장 일반적인 구조

클러스터의 노드에 다양한 연산 작업을 분할하여 향상된 성능을 제공, 한 노드의 계산한 중간 결과를 다른 노드에게 제공해 미래 계산에 적용 가능

주로 과학 분야나 슈퍼 컴퓨터 등에 사용된다.

그림 11-37은 고성능 클러스터의 자원 관리 시스템의 예시이다.
자원 관리 시스템은 제한된 계산 자원의 효율성과 활용도를 높이고, 경쟁을 방지하는 작업 처리를 관리함.

![](2022-07-29-19-28-03-image.png)

크게 작업 스케줄러와 자원 관리자로 구성된다.

스케줄러가 가용성 자원의 스케줄링 결정과 연산 노드에 할당 등의 활동을 하며 이를 위해 작업 큐 정보를 얻기 위해 자원 관리자와 통신하는 구조

**자원 관리자**
- 노드 상태의 모니터링
- 요청한 작업을 수신
- 작업 요청을 노드에서 실행할 수 있도록 할당
- 일부는 기본 스케줄링이나 정책 제어

자원 관리자를 통해 시스템 사용률을 향상 가능

**작업 스케줄러**
- 우선 작업, 작업 스케줄링, 정책 및 조직의 목표 등을 고려해 작업 우선순위 결정
- 사용 가능한 자원과 작업 큐를 자원 관리자에게 입력받아 우선순위 결정에 고려함

**기본형 클러스터** : 모든 노드의 하드디스크에 독립적으로 운영체제를 모두 설치하여 자체적으로 파일과 라이브러리를 해결

**디스크 없는 클러스터** : 서버 노드 한 대에만 하드디스크가 있어 다른 노드는 서버 노드의 파일 시스템을 사용

#### 4.3 부하분산 클러스터(LBC, Load-Balancing Clusters)
그림 11-38과 같이 외부 클라이언트의 작업 요청을 부하 분산 서버, 혹은 부하 분배기(load balancer)가 받아들여 부하량이 가장 적은 노드에 요청을 전달하는 방식이다.

따라서 단일 서버를 사용 시 발생하는 부하를 다른 노드로 분산시켜 웹 서버의 과부하를 해결 할 수 있으며, 사용자가 많은 서비스에 어울리는 구조이다.
![](2022-07-29-19-28-24-image.png)

부하분산 클러스터는 구현 방법에 따라 DR, NAT 등으로 구분
- **DR(Direct Routing)**
	클라이언트에 들어온 요청을 부하 분산 서버가 다른 컴퓨터에 분배하고, 요청을 할당 받은 컴퓨터가 직접 응답하는 방법
	실제 서버의 공인된 IP를 통해 서로 직접 연결한다.
- **NAT(Network Address Translation)**
	클라이언트의 요청을 처리하는 실제 서버는 부하 분산 서버를 경유해 사용자에게 전송하는 방법
	➕ 부하 분산 서버와 실제 서버 사이는 사설 IP를 사용하기 때문에, 공인 IP가 실제 서버 수만큼 필요치 않다.
	➖ 하지만 부하 분산 서버가 고장 나면 전체 서비스가 불가
	이를 극복하기 위해 부하 분산 서버를 여러 대 두는 고가용성 클러스터를 함께 이용하기도 한다. 

**부하 분산 서버의 실제 서버 스케줄링 방법**

- **순환 할당 스케줄링(라운드 로빈, Roundrobin)**
	모든 노드에 동등하게 돌아가며 할당
- **가중치(weighted) 기반 순환 할당 스케줄링**
	각 서버마다 가중치를 부여하고 가중치에 따라 요청 할당
- **최소 연결 스케줄링**
	가장 연결이 적은 서버에서 요청을 직접 연결하는 방법, 각 서버에서 동적으로 실제 연결한 숫자를 계산해야 함.
- **가중치 기반 최소 연결 스케줄링**
	가중치 비율을 실제 연결자 수에 따라 설정해 네트워크 연결 할당
	
#### 4.4 고가용성 클러스터(HAC, High-Availability Clusters)
시스템이 실패하면 중복 노드를 운영하여 서비스를 제공하는 방식
이를 통해 서비스의 고가용성을 제공할 수 있다.

그림 11-39와 같이 컴퓨터 두 대에 같은 소프트웨어와 하드웨어를 설치하고, 컴퓨터 두 대 사이를 고속 네트워크로 연결하여 서로 상대방의 현재 상태를 검사한다.

![](2022-07-29-19-28-35-image.png)

두 가지 방법으로 구현될 수 있다.
- 두 대의 동일한 서버가 전체 서비스를 분할하여 제공해 성능 향상에 이용되다가 한 쪽이 고장 시, 나머지 정상 서버가 모두 인계 받아 실행
- 두 대의 동일한 서버 중 한 대는 아무 작업도 하지 않다가 서비스를 제공하는 컴퓨터가 고장이 나면 모든 서비스를 넘겨 받음

#### 4.5 클러스터의 성능에 미치는 요소
- 클러스터의 노드 수가 많으면 관리하기 힘들다.
- 고장난 노드 수가 많으면 시스템 성능이 떨어진다.
- 네트워크의 성능 : 노드 간의 수시로 주고받는 정보 전송 속도와 신뢰도
- 프로세서의 성능 : 노드 작업의 요청이 많고 고연산을 요구하면 작업이 쌓이면서 네트워크 병목 현상이 생김
	- 이를 해결하기 위해 노드를 추가하거나 RAID 시스템 활용
- 입출력 응용 프로그램은 어느 노드에서든 입출력 장치, 메모리에 액세스할 수 있도록 단일 입출력 공간 (SIOS, Single I/O Space)를 구현한다.
- 클러스터 시스템을 통홥된 자원으로 사용할 수 있도록 SSI 기능 제공

