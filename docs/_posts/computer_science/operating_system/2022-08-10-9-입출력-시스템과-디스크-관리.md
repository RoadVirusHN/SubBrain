---
title: "9. 입출력 시스템과 디스크 관리 - 운영체제 학습 정리"
date: 2022-08-10 23:23:16 +0900
tags: OS CS 컴퓨터_구조 요약
layout: obsidian
is_Finished: false
last_Reviewed: 2022-10-28 14:05:09 +0900
use_Mathjax: true
---
```toc

```

# 9. 입출력 시스템
```ad-quote
title: 참고 서적
[IT COOK BOOK 운영체제 (개정 3판, 구현회 저, 한빛 아카데미)](https://www.hanbit.co.kr/store/books/look.php?p_code=B3239422381)를 참고로 정리한 내용입니다.
```
## 01 입출력 시스템 관리
### 1 입출력 시스템과 입출력 모듈
입출력 시스템은 모니터, 키보드 같은 하드웨어인 입출력 장치와 입출력 모듈까지 포함한다.
- 입출력 장치 : 실제 사용자와 입출력 수행
- 입출력 모듈 : 메모리나 프로세서, 레지스터 등 내부 저장장치와 물리적 입출력 장치 사이의 이진 정보를 전송
    - 입출력 채널(I/O channel), 입출력 프로세서(I/O Processor) : 프로세서를 대신해 입출력과 관련된 복잡한 일 처리
    - 입출력 제어기(I/O Controller), 장치 제어기(device controller): 단순 프로세서의 입출려과 관련된 일을 담당

![](2022-07-21-00-31-31-image.png)

그림 9-1처럼 주변 장치를 직접 시스템 버스에 연결 하지 않고 입출력 제어기로 연결한다.
입출력 장치에 따라 입출력 속도, 제어 및 운용법이 다르기 때문이다.

주로 정보 단위(워드, 문자, 블록), 처리량 등을 동기화한다.

### 2 입출력 모듈의 구성
아래 그림은 일반적인 입출력 모듈의 구성이다.
![](2022-07-21-00-32-04-image.png)

- 데이터 레지스터 : 입출력 모듈로 출입하는 데이터를 일시적으로 저장
- 제어 레지스터 : 상태 레지스터를 프로세서의 명령에 따라 동작
- 상태 레지스터 : 현재의 상태 정보를 저장, 제어 레지스터에 의해 동작
- 입출력 논리회로 : 상태 레지스터의 정보를 제어하는 장치의 주소로 인식하고 각 장치와 인터페이스를 제어
- 제어 버스: 프로세서와 교신 
 
### 3 입출력 모듈의 기능

- **내부 자원과 데이터 입출력 등의 다양한 동작 제어 및 타이밍**
  - 입출력 모듈이 외부 장치 타이밍, 데이터 형식, 기계적 동작 등을 처리하므로 프로세서는 단순히 파일 열기와 닫기로 장치를 제어할 수 있다.
  - 프로세서가 입출력 장치에 명령을 보내기 위해 입출력 장치의 식별자를 주소로 지정하는 방법 두 가지
    - 전용 메모리 주소 공간에 주소 지정하는 전용 입출력 방법
    - 메인 메모리 주소 공간 일부를 입출력 주소 공간으로 공유하는 메모리 매핑 주소 방법, 유연성, 인터럽트 신호가 특징
- **프로세서에서 명령을 전달받고, 관련된 메시지를 인식**
  - 메시지 인식 순서
    1. 명령 해독 : 프로세서에서 명령들을 받아 해독한다.
    2. 데이터 교환 : 데이터 버스로 프로세서와 데이터를 교환
    3. 상태 보고 : 저속 주변장치의 상태를 확인하여 프로세서에 보고
    4. 주소 인식 : 모듈에 연결된 여러 장치를 구분할 주소를 인식
- **버퍼링을 이용해 전송속도 조절**
  - 메인 메모리와 입출력 장치 간의 속도 간극을 해결하기 위해 버퍼를 이용해 데이터 전송
- **오류 검출**
  - 종이걸림 같은 기계적 오류, 전송 오류 등의 검출을 위해 패리티 비트 같은 오류 검출 코드 사용

### 4 프로세서 역할에 따른 입출력 방법

프로세서와 입출력 장치의 입출력 방법에 따라 다음과 같이 나눌 수 있다.
#### 4.1 프로그램 제어 입출력 방법

프로세서 내부의 입출력 데이터와 주소 레지스터를 입출력 모듈과 직접 연결, 전송하는 형태

프로세서가 입출력 장치의 상태 비트(status bit)를 주기적으로 확인하므로 폴링(polling) 방법이라고도 한다.

![](2022-07-21-00-32-34-image.png)

입력 시, 워드 단위로 입출력 장치, 입출력 모듈을 거쳐 입출력 데이터 레지스터로 이동한 뒤, 프로세서의 산술 논리 연산 장치로 보내져 처리된다.

반대로 출력 시, 산술논리 연산장치의 결과를 입출력 데이터 레지스터로 이동하고 프로그램을 이용해 입출력 모듈로 전송한다.

![](2022-07-21-00-32-51-image.png)

데이터 전송 시에는 장치의 포트 상태 레지스터에 저장되있는 입출력 장치의 상태 비트를 폴링 순환 (그림 9-4)을 통해 검사한다.

폴링 순환이 너무 잦으면 시간과 자원 낭비가 생기고, 너무 적으면 입출력 장치가 너무 오래 쉬게 된다.

\+ 하드웨어가 적게 필요
\+ 입출력 장치가 직접 메모리에 접근하지 않음. 보안상 유리

\- 프로세서가 데이터 입출력에 관여하므로 프로세스 부담이 큼
\- 데이터 처리속도 느림, 프로세서의 명령어 인출 및 실행이 데이터 입출력이 끝난 뒤 실행
  - 키보드, 문자 모드의 프린터와 모니터 등 저속장치에 적합

> 🔵 상태 비트 뿐만 아니라 메인 메모리에 3비트로 구성된 채널 상태 워드(channel status word)가 존재하며, 각각 채널, 제어장치, 각 장치의 사용 가능 여부가 표시되어 있다.

#### 4.2 인터럽트 기반 입출력 방법

입출력 장치가 작업을 완료시 상태와 결과를 메모리에 저장 후, 인터럽트를 발생시켜 프로세서에게 알리는 방법

![](2022-07-21-00-33-03-image.png)

프로세서는 이후 메모리에서 작업 결과를 확인하고 다른 입출력 명령을 전송할 수 있다.

![](2022-07-21-00-33-25-image.png)
위 그림은 인터럽트 기반 입출력 방법의 과정이다.

\+ 폴링 절차 불필요, 입출력 연산 대기시간 없음
\+ 불규칙적이고 빠른 응답에 적합

\- 작업 내용을 스택에 저장해야 하는 오버헤드
\- 프로세스 레지스터 내 모든 데이터 전송 필요

#### 4.3 DMA(Direct Memory Access, 직접 메모리 제어) 입출력 방법
입출력 모듈이 프로세서의 도움 없이 메인 메모리를 직접 제어해 데이터를 전송

![](2022-07-21-00-33-57-image.png)

DMA 입출력의 기본 구성은 위와 같다.

입출력 장치를 위한 메모리에 연속된 일부분을 할당한다.

DMA 제어기
- 입출력 중 모든 버스 제어 신호를 생성 및 제어하므로 버스 마스터 역할을 맡기도 함.
- 버스 우선순위가 높기 때문에 버스와 메모리를 프로세서가 사용할 때 사이클 스틸링 하기도 함.
    - 사이클 스틸링(cycle stealing) : 프로세서 도움없이 메모리 접근, 독점적으로 액세스
    - 프로세서의 속도를 떨어뜨리지만, 입출력 작업을 DMA에 전담시켜 전체 성능 향상
- 통용적으로 사용되는 물리적 주소 말고 직접 가상 주소 액세스(DVMA, Direct Virtual Memory Access)를 이용해 메모리에 액세스 하기도 함


\+ 프로세서는 이 과정에 개입하지 않으므로 프로세서 부담이 적어

\+ 디스크 데이터 전성과 멀티미디어 같은 대용량 데이터 전송에 적합

\- 외부 제어기, DMA 제어기 등의 하드웨어가 필요

![](2022-07-21-00-34-20-image.png)

1. 프로세서가 읽기와 쓰기 정보, 입출력 주소와 메모리 주소, 길이를 DMA 제어기에 전달해 입출력 요청
2. DMA 제어기가 입출력 처리
3. 입출력 모듈이 메모리로 블록 단위로 데이터 전송
4. DMA 제어기가 프로세서에게 인터럽트로 종료 통보
5. 프로세스가 메모리에 보관된 데이터를 사용

입출력 채널 : IBM에서 DMA 제어기가 존재하는 입출력 모듈, 채널 프로그램을 통해 DMA 입출력을 수행한다.

#### 4.4 입출력 채널을 이용한 입출력

입출력 채널 : 프로세서와 메인 메모리를 입출력 장치에 결합해 프로세서의 명령으로 입출력을 제어하는 장치
- 지역 기억 장치 또한 가지고 있으며, 많은 입출력 장치를 공유하고 제어
- 입출력의 모든 동작은 프로세서의 개입없이 진행하고 종료 후, 인터럽트를 보내 완료를 보고한다.
- DMA 제어기(메모리 접근) + 입출력 명령어(입출력 동작 실행)
  - 이때 입출력 명령어는 메인 메모리에 존재한다. 

![](2022-07-21-00-34-37-image.png)

그림 9-9는 입출력 채널 구조의 예이다. 

**채널 경로**: 여러개 존재 가능, 프로세서와 메인 메모리의 액세스를 조정할 수 있다.
**채널** : 사이클 스틸을 사용해 메모리에 직접 접근
**입출력 장치** : 제어장치를 사용해 채널과 연결
**제어 장치** : 채널과 통신하고 장치를 제어, 유사한 장치끼리는 이를 공유함.

![](2022-07-21-00-34-58-image.png)

입출력 채널 또한 그림 9-10처럼 여러개로 나뉜다.

- 실렉터 채널(selector channel)
    - 어떤 장치를 고르고 입출력 종료할 때까지 다른 장치를 실행하지 않도록 한다.
    - 자기디스크, 테이프 같은 장치가 고속으로 전송할 때 대량의 데이터를 전용 채널로 이동할 때 다중화하는 방법
- 멀티플렉서 채널(multiplexer channel)
  - 바이트 단위로 시분할해 여러 장치의 출력을 처리
  - 주로 저속, 중속 장치(카드리더, 프린터)등에 사용
  - 채널-메모리 연결이 다수의 느린 장치의 데이터 전달보다 훨씬 빠르므로 동시에 처리 가능하다.
  
- 블록 멀티플렉서 채널(block multiplexer channel)
  - 실렉터 채널 + 멀티 플렉서, 여러 대의 고속 입출력 장치를 블록 단위로 동시 처리 가능
  - 장치 하나와 입출력 명령어 수행 후, 다른 장치로 빠르게 변환

### 5 커널 입출력 서브시스템
입출력 모듈 : 프로세서와 장치 드라이버, 장치 간의 데이터를 전송 제어
커널 : 입출력 인터페이스를 제공한다.

#### 5.1 커널 입출력 구조
커널 : 입출력 서비스와 입출력 인터페이스 제공

응용 프로그램 : 커널이 제공하는 서비스를 각자 모델이나 제조사에 따라 액세스 가능하도록 표준함수로 제공
(소프트웨어 드라이버?)

장치 드라이버 (하드웨어 드라이버?) :
- 응용 프로그램에서 제공한 함수를 수행 
- 입출력의 결과의 장치마다 차이를 표준 인터페이스로 변환하여 상위 커널 입출력 서브 시스템에 제공 

하드웨어: 소프트웨어 드라이버의 함수에 입출력 실행 후, 장치 드라이버에 돌려줌. 

![](2022-07-21-00-35-14-image.png)

#### 5.2 커널이 제공하는 입출력 서비스

커널 입출력 서브 시스템은 아래와 같은 다양한 서비스를 제공해 컴퓨터 효율성을 증진시킨다.

- **입출력 스케줄링**
    입출력 요구를 전반적인 시스템 성능 향상을 위해 공평하게 처리하도록 실행 순서를 결정

- **버퍼링**
    입출력 장치와 응용 프로그램 사이에 전송되는 데이터를 버퍼에 임시로 저장하는 방법

    ![](2022-07-21-00-35-29-image.png)
    그림 9-12의 (a)의 경우 데이터가 디스크에 도착할 때까지 기다려야 한다.
    (b)의 경우, 메모리에 버퍼를 만들어, 버퍼가 찬 이후 한꺼번에 전송하기 때문에 디스크는 그 동안 다른 일을 할 수 있다.
    (c)의 경우, 추가로 버퍼를 하나 추가하여, 버퍼의 데이터가 디스크에 쓰여지고 있는 와중에도 전송을 할 수 있게 해준다.

    추가로 버퍼를 통해 패킷 등의 데이터의 단위를 변환하기도 한다.
- **캐싱**
    명령어와 데이터를 캐시에 일시적으로 저장하여 프로세서와 메모리 간의 액세스 속도 차이를 줄여 컴퓨터 성능을 향상

    버퍼와의 차이점은 캐시는 데이터의 복사본을 저장한다는 점이다.

    때로는 버퍼가 캐시 역할을 수행하기도, 캐시가 버퍼 역할을 수행하기도 한다.

    일반적으로 캐시는 RAM 보다 빠르고 크기가 작다.

- **스풀링**
    하나의 출력장치로 여러 요청이 동시에 간다면, 커널은 이러한 요청을 각각 나누어 디스크 파일에 스풀링한 뒤, 큐에 삽입하여 차례대로 처리한다. 보통 커널 스레드를 이용한다.

- **오류 처리**
    입출력 장치 고장, 네트워크 전송 오류로 발생하는 일시적인 고장을 해결

- **자료 관리**
    입출력 구성의 상태 정보를 유지.
    커널 대신 독립 프로그램이 상태 정보를 유지할 때의 장단점은 다음과 같다.
    
    \+ 입출력 시스템의 구조와 설계가 간단, 운영체제 커널의 크기가 작고 유연함
    \- 장치 드라이버와 커널의 정보 공유로 메시지를 교환하려는 오버헤드가 증가

    상태 정보의 예시는 다음과 같다.

  - 장치 이름과 장치 액세스 제어 관리
  - 장치 할당과 입출력 스케줄링 관리
  - 버퍼링, 캐싱, 스풀링 관리
  - 장치 상태 모니터링과 오류 처리, 고장 복구 관리

## 02 디스크의 구조와 스케줄링

### 1 디스크의 구조

- 보조기억 장치의 목적: 방대한 데이터를 낮은 가격으로 영구히 저장하는 것.
- 메모리에 비해 접근 시간이 느리고 순차 접근만 허용
- 주로 자기 디스크가 사용된다. 최근에는 SSD로 넘어가는 추세지만 여전히 자기 디스크가 싸다.
- 디스크는 컴퓨터 장치 중 가장 느려 시스템 전체의 성능과 신뢰성에 많은 영향을 끼치므로, 메모리나 캐시 등이 발달해도 여전히 중요함

![](2022-07-21-00-38-21-image.png)

**디스크의 원리**
- 양 표면에 자기 물질을 입힌 원판 모양의 디스크에 정보를 기록
- 표면을 여러 논리적 트랙으로 나누고 입출력 헤드를 통해 기록한다.

**헤드 이동 방식**
그림 9-13(a)의 경우 트랙마다 고정 헤드가 존재하는 고정 헤드 디스크이며, 그림 9-13(b)은 이동 헤드 디스크로, 헤드를 암 이동 장치를 이용해 이동시키는 방식이다.

**디스크 성능 높이기**
그림 (b)처럼 디스크를 한축에 여러개 쌓거나 양면으로 이용해 저장 공간을 늘리거나, 램  디스크, 고속 디스크를 이용해 빠르게 데이터 전송을 할 수 있게 한다.

**디스크 시스템 구성**
- 디스크 드라이버 : 디스크의 기계적 동작 제어 담당
  - 구동 모터
  - 액세스 암 이동장치
  - 입출력 헤드
- 디스크 프로세서 : 원하는 데이터 위치(주소)와 버퍼, 판독, 기록 등 을 관리
- 디스크 제어기 : 디스크 드라이버의 인터페이스

![](2022-07-21-00-38-36-image.png)

**디스크 작동 순서**
1. 디스크 제어기가 프로세서에게 명령을 받음
2. 디스크 제이기를 통해 디스크 드라이버 작동
3. 디스크 드라이버가 탐색, 기록, 판독 등을 수행
    - 이때, 디스크의 주소는 드라이버 번호, 표면 번호, 트랙 번호로 구성됨
- **트랙(track)**: 원형 평판 표면에 데이터를 저장 할 수 있는 동심원, 자기장 간섭을 막고, 헤드 정렬을 위해 일정한 이격으로 구분
- **실린더(cylinder)** : 동일한 동심원으로 구성된 모든 트랙의 집합, 헤드의 움직임 없이 액세스할 수 있는 모든 트랙들
- **섹터(sector)** : 트랙을 부채꼴 모양으로 나눔, 섹터는 트랙을 하드웨어적으로 일정 크기로 고정되어 나뉘면서 생긴다. 기록의 기본 단위로 보통 512바이트이며, 고유 번호가 존재해 위치 판별에 쓰임

### 2 디스크 액세스 시간
디스크의 섹터를 액세스할 수 있는 시간, 탐색 시간 + 회전 지연시간 + 전송 시간으로 이루어져 있다.
![](2022-07-21-00-39-02-image.png)
- 탐색 시간(seek time) : 헤드를 해당 트랙이나 실린더에 위치시켜 원하는 섹터에 접근하는데 걸리는 시간 
    - 고정 헤드 디스크는 각 트랙마다 헤드가 있으므로 0
- 회전 지연 시간 : 헤드가 지정된 트랙의 원하는 섹터가 입출력 헤드 아래로 회전할 때까지 기다려야 하는 시간
- 전송 시간 : 디스크와 메인 메모리 간의 섹터를 주고 받는데 걸리는 시간

**디스크 주소 표현**
메모리와 디스크 사이의 입출력은 하나 이상의 섹터 단위로 전송하며, 디스크 주소 b는 다음과 같이 표현한다.
트랙당 섹터 수=s
실린더당 트랙 수=t
실린더 번호=i
표면 번호=j
$$
b= k+s\times(j+i\times t)
$$
블록 b+1을 액세스 할대는 헤드가 한 트랙만 옮기면 된다.

디스크에는 어떤 파일이 있는지 표시하는 장치 디렉터리가 있으며, 장치 디렉터리는 파일 이름으로 리스트를 나타낸다.
- 파일의 길이
- 파일의 종류
- 파일의 소유주
- 생성된 날짜
- 사용한 시간
- 부호
등의 파일 정보를 포함한다.
### 3 디스크 스케줄링의 개념과 종류

입출력장치(디스크 드라이버)에는 요청 큐가 있으며, 다음과 같은 정보를 포함한다.
- 입력, 출력 구분 정보
- 디스크 주소
- 메모리 주소
- 전송할 정보의 총량(바이트, 워드 기준)

이후, 디스크 드라이버와 제어기를 사용할 수 있을 때까지 큐에서 대기하며, 다음과 같은 기준으로 순서를 평가하는 알고리즘을 쓴다.
- 처리량 최대화: 시간당 처리한 서비스 요청 수
- 탐색 시간 최소화: 디스크 헤드 이동 시간
- 평균 반응시간 최소화: 요청 후 서비스 할 때까지 대기시간
- 반응(응답) 시간 변화 최소화: 반응시간 예측 정도, 무기한 연기 방지, 예측 가능한 응답시간

![](2022-07-21-00-39-34-image.png)

디스크 스케줄링은 크게 탐색 시간 최적화와 회전 지연시간 최적화 알고리즘으로 분류된다.
최근 디스크는 탐색 시간과 평균 지연 시간이 비슷하고 대화식 프로세스가 많아 회전 최적화로 성능을 개선한다. 
일괄 처리 프로세스는 데이터 트랙 전체를 액세스 하기 때문에 탐색 시간 최적화가 낫다.
### 탐색 시간 최적화
#### 4 선입선처리(FCFS, First Come First Served) 스케줄링
요청이 도착한 순서에 따라 처리하는 가장 쉽고 간단한 알고리즘

![](2022-07-21-00-39-55-image.png)

\+ 구현이 쉽다
\+ 무기한 연기 없이 공평하다.
\+ 실행 시간 오버헤드가 적다

\- 서비스 지연 요청(헤드에서 먼 요청)에 의한 탐색 시간 증가
\- 처리량 감소
#### 5 최소 탐색 시간(SSTF, Shortest Seek Time First)우선 스케줄링
현재 헤드 위치에서 가까운 요청부터 처리하는 방법
![](2022-07-21-00-40-07-image.png)
\+ 비교적 처리량 증가, 반응시간 감소
\+ 일괄 배치 처리 시스템에 적합

\- 예측 불가한 처리 시간, 대화형 시스템에 부적합
\- 공정성 없음, 디스크 요구의 기아 발생 가능
  - 만약, 0 위치에 헤드가 존재할 때, 1~10 위치의 요청이 무한히 발생한다면, 120 위치의 요청은 영원히 실행되지 않을 것

#### 6 스캔(SCAN) 스케줄링
헤드가 디스크의 한쪽 끝과 다른 끝 사이를 계속해서 왕복하면서 한 방향으로만 서비스하다 디스크 가장 자리에 도달하면 역방향으로 전환하는 스케줄링
엘리베이터의 동작과 유사해 엘리베이터 스케줄링이라고도 한다.

![](2022-07-21-00-40-20-image.png)

위 그림은 스캔 스케줄링의 예시로, 반대 방향으로 먼저 가도 스캔 스케줄링이다.

만약, 새로운 요청이 헤드의 경로 바로 앞에 생성되면, 다른 앞선 요청들 보다 먼저 처리한다.

반대로 새로운 요청이 헤드의 경로 바로 뒤에 생성되면, 다시 돌아올 때까지 오랫동안 기다려야 한다.

#### 7 순환 스캔(C-SCAN, Circular-SCAN) 스케줄링
헤드가 한쪽 방향으로 이동하다 한쪽 끝에 다다르면 반대쪽 끝으로 즉시 이동한 뒤, 같은 방향으로 진행하는 방식이다.
![](2022-07-21-00-40-34-image.png)
스캔 스케줄링의 변형이며, 대기시간을 좀더 균등하게 하고, 처리량을 향상 시킨다.

#### 8 N-단계 스캔 스케줄링
디스크 요청 큐를 N개의 서브큐로 분할 하고, 각 서브 큐 내부 스캔을 사용해 하나씩 처리하는 방법
N이 크면 스캔 알고리즘, N=1이면 선입 선처리 알고리즘과 동일하다.
유연하지만 복잡하다.

#### 9 룩(LOOK, C-LOOK) 스케줄링
순환 스케줄링처럼 이동하다, 현재 방향 경로에 요청이 없다면 경로를 바꾸는 알고리즘
룩은 진행 방향으로 움직이기 전에 요청을 검사하기 때문에 생긴 이름이다.
![](2022-07-21-00-42-03-image.png)
스캔 스케줄링 보다 더 효율적이다.

### 회전 지연시간 최적화
#### 10 최소 지연시간 우선(SLTF, Shortest Latency Time First) 스케줄링
모든 요청 중 회전 지연 시간이 가장 짧은 요청부터 처리하기 위해 디스크 헤드가 특정 실린더에 도달 시, 해당 실린더의 모든 요청을 먼저 처리한다.
![](2022-07-21-00-42-25-image.png)
정확히는, 섹터 위치에 따라 큐에 넣은 후, 가장 가까운 섹터 요청을 먼저 처리한다. 따라서 섹터 큐잉(sector queuing) 알고리즘이라고도 한다.
\+ 탐색 시간이 없는 고정 헤드 디스크에 효과적이다.
\+ 특별한 트랙마다 실린더 내에 처리 요청이 하나 이상일 때는 이동 헤드 장치에도 쓸만하다.
![](2022-07-21-00-42-50-image.png)

\+굳이 대기큐 앞부분에 잇지 않더라도 헤드가 해당 섹터를 지나간다면 요청을 처리하도록 하여 처리율을 늘릴 수 있다.


#### 11 최소 위치 결정 시간 우선(SPTF, Shortest Positioning Time First) 스케줄링 
탐색 시간과 회전 지연시간의 합이 가장 짧은 요청을 먼저 고른다.
\+ 처리량과 평균 반응 시간 성능이 좋다.
\- 가장 안쪽과 바깥쪽 실린더의 요청이 무기한 연기될 수 있다.(중간 쯤의 실린더는 평균적으로 가깝기 대문이다.)
![](2022-07-21-00-43-04-image.png)
위 그림 같은 경우 긴 시간이 걸리는 회전 지연시간이 더욱 긴 A보다는 다른 트랙에 있어 탐색 시간이 더 걸리더라도 회전 지연시간이 짧은 B를 먼저 처리할 것이다.

> 🔵 에센 바흐 방법(Eschenbach Scheme)
> 헤드는 순환 스캔 스케줄링 처럼 진행, 한쪽 방향으로 디스크를 회전 시키면서 만나는 요청을 처리
> \+ 회전 지연시간 최소화
> \- 요청 2개가 실린더의 동일 섹터에 있으면 하나만 처리하고 나머지 하나는 한바퀴 돈 뒤에 처리

### 12 디스크 스케줄링 알고리즘의 선택

#### 스케줄링 선택법
최소 탐색 시간 우선 스케줄링은 일반적 선택
스캔, 순환 스캔 스케줄링은 디스크 부하가 클 경우 선택
선입선출 스케줄링은 디스크 요청이 극단적으로 적을 때 선택 

#### 스케줄링 성능에 영향을 끼치는 요인
- 요청의 형태와 수에 따라 최적의 알고리즘은 달라진다.

- 파일 할당 방법 또한 영향을 끼침
  - 연속적으로 할당된 파일을 읽으면, 헤드 이동이 해당 연속으로 강제됨
  - 링크 파일이나 색인 파일은 디스크 여러 위치에 흩어져 반응 시간은 느리지만, 저장 효율은 높음

- 디렉토리 구조 탐색에 많은 디스크 사용이 있으므로, 디렉토리는 디스크 중간 부분에 두는 것이 효율적이다.

## 03 RAID

### RAID의 소개
- RAID(Redundant Array of Inexpensive Disks(혹은 Independent Disks))는 운영체제로 여러 대의 물리적 디스크를 하나의 논리적 디스크로 인식하는 기술
- 다수의 장치를 병렬로 구성, 처리하여 성능과 안전성을 향상 시킬 수 있음
### 2 RAID 계층
- 방법과 용도에 따라 총 6계층으로 분류
- 구성하기 위해 소프트웨어 RAID 카드나 물리적 RAID 카드 필요
- 최근에는 RAID 0, RAID 1, RAID 0+1, RAID 5를 제외하고 거의 사용되지 않거나 지원하지 않는다.

#### 2.1 RAID 0(스트라이핑)
일련의 데이터를 논리적 디스크 배열 하나에 일정한 크기로 나눠서 분산 저장하고, 이를 논리 디스크 하나에 저장된 것처럼 이식하는 방법
일정한 섹터 혹은 블록 단위인 스트립(strip)으로 나누어 연속적인 배열 첨자와 대응되도록 순환 할당.

![](2022-07-21-00-43-21-image.png)

그림 9-28에서 데이터 ABCD를 A, B, C, D로 병렬로 분산 저장했는데, 이 각각의 A, B, C, D를 스트립(strip)이라고 하며, 연속된 데이터 ABCD는 스트라이프(stripe)라고 한다.

\+ 동일한 하드디스크 n대로 데이터를 병렬로 저장하여 입출력 전송시간을 n배로 늘릴 수 있다.
\- 한 디스크 이상에서 장애 발생 시, 데이터 손실, 즉 전송시간 n배로 늘리는 대신 안전성은 1/n배

주로 빠른 데이터 입출력 성능을 요구하는 중요하지 않은 동영상 편집 등에 적합하다.

#### 2.2 RAID 1(미러링)

데이터 스트라이핑을 사용하면서 배열 내의 모든 디스크를 미러링(mirroring)을 통해 동일한 데이터가 있는 미러 디스크를 가진다.

![](2022-07-21-00-43-37-image.png)

\+ 드라이브 장애 발생 시 즉각 두번째 디스크로 복구 가능 안전성이 n배
\+ 읽기 성능 n배 향상 됨
\- 전체 용량의 절반을 여분의 데이터 기록에 사용하므로 디스크 공간이 두배가 필요
\- 쓰기 성능은 단일 드라이브와 같음
  - 그림 9-29의 경우에는 쓰기 성능 또한 4배 증가하는게 맞다. 다만 맨 앞에 두 디스크만 있는 경우는 쓰기 성능은 1배이다.

쓰기가 적고 읽기가 중요하며, 안전성이 중요한 시스템 드라이브 같은 중요한 파일에 적합 

#### 2.3 RAID 2(허밍 코드를 이용한 중복)
데이터 스트라이핑과 오류 감지 및 수정을 위한 허밍 오류 정정 코드(Hamming Error Correcting Code, Hamming ECC)를 저장하는 드라이브로 이루어져 있다.
허밍 오류 정정 코드는 패리티 비트를 이용해 디스크에 전송된 데이터 오류가 있는지 확인하고 정정한다.

![](2022-07-21-00-44-03-image.png)

오류 정정 코드는 각 데이터 디스크에 대응하는 비트를 계산한다. 
그림 9-30은 데이터 A를 A0, A1, A2, A3로 스트라이핑 한다.
이후 생성한 허밍코드를 패리티 디스크에 ECC/Ac, ECC/Ay, ECC/Az로 저장한다.

\+ 실시간 오류를 감지 및 수정 가능
\+ 빠른 기록 속도 (스트라이핑 하므로)
\+ 장애 복구 능력 (오류 수정으로)
\+ 디스크 두개의 작은 시스템에도 적용 가능

\- 디스크 공간 낭비
\- 최신 SCSI 드라이브는 자체적으로 오류 검출 능력 존재

```ad-note
title: 허밍 코드
패리티 비트를 필요한 수만큼 정해진 위치에 두어 오류가 발생했을 때 오류 발생 비트를 알아내어 정정이 가능도록 함.
- 허밍 코드의 비트 수 : 정보 비트의 수가 m이면 패리티 비트 수 p는 2p >= m+p+1
- 패리티 비트의 위치 : 허밍 코드의 왼쪽부터 1, 2, 4, 8, 2n-1에 위치

ex) 정보 비트 4, 패리티 비트 3 (P1, P2, D1, P3, D2, D3, D4)(1,2,4번 자리에 패리티 비트 위치)
```

#### 2.4 RAID 3(비트 인터리브된 패리티)

스트라이프를 이용한 분산 저장, 별도의 드라이브 한대를 패리티 드라이브로 이용해 오류 검출과 수정에 사용함

![](2022-07-21-00-44-18-image.png)

데이터 복구는 다른 드라이브에 기록된 정보에 XOR을 계산해 수행
나머지 디스크에는 스트라이프하여 분산 저장한다.

\+ 스트라이프에 의한 높은 데이터 전송률
\+ 패리티 비트를 이용한 오류 탐지 및 수정

\- 입출력 작업을 한번에 한 요청만 실행하므로 빈번한 입출력에 좋지 않음
  - 즉, 속도는 빠르지만 한번에 한번만 실행

대형 레코드를 많이 사용하는 단일 사용자 시스템, CAD, 이미지 작업에 적합

#### 2.5 RAID 4(블록 인터리브된 패리티)

RAID 3와 비슷하지만 데이터를 블록 단위로 분산 저장하여 각 디스크에서 독립적으로 입출력을 할 수 있다.
![](2022-07-21-00-44-36-image.png)

기존의 비트 단위 저장의 경우 데이터 출력과 단위가 달라 의미없이 나누었지만, 블록 단위 저장의 경우 각 디스크가 데이터의 의미가 있도록 나누어, 각기 다른 입출력이 가능하다.

쓰기는 패리티 비트를 수정해야 하므로 느리지만 읽기는 RAID 0와 비슷한 성능을 보인다.

\+ RAID 3의 장점에 추가로 각 디스크가 각기 입출력 진행 가능
\+ 저렴한 가격으로 장애복구 능력과 빠른 읽기 속도

\- 크기가 작은 입출력의 성능이 떨어짐 (작은 변화에도 패리티 정보를 갱신해야 하므로)
- 따라서 높은 데이터 전송률이 필요할 때는 성능이 떨어짐

#### 2.6 RAID 5(블록 인터리브된 분산 패리티 블록)
별도의 패러티 드라이브 대신 모든 드라이브에 패리티 정보를 나눠서 저장한다. 
![](2022-07-21-00-44-48-image.png)
다른 모든 장점을 가지고 있어 가장 널리 사용되는 RAID 방법이다.

\+ 쓰기에서 패리티 수정 동작이 디스크 병목 현상을 일으키지 않않음
\+ 병렬 입출력, 동시 읽기 기록, 데이터 입출력 성능 빠름, 안정성 높음

\- 최소 3대, 보통 5대 이상의 드라이브가 필요, 소규모 시스템 부적합
\- 읽기 요청은 각 드라이브에서 패리티 정보를 건너뛰어 RAID 4보다 비교적 느림

#### 2.7 RAID 0+1
스트라이핑과 미러링 방법을 혼합한 형태

![](2022-07-21-00-45-05-image.png)

\+ 안전성과 빠른 속도 모두 확보

\- 최소 4개의 디스크 필요
\- 미러링으로 인해 용량이 절반으로 줄어듦