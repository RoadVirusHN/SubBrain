---
title: JAVA 기본-예외 처리
date: 2023-02-01 15:49:17 +0900
tags: HIDE CRUDE 
layout: obsidian
is_Finished: false
last_Reviewed: 2023-02-01 15:49:17 +0900
use_Mathjax: true
---

```toc
style: number
min_depth: 2
max_depth: 3
varied_style: true
```

# 예외 처리

## 예외처리
### 예외 처리
#### 예외의 개념
- 에러(Error) : 프로그램으로 처리할 수 없기 때문에 에러 발생시 프로그램 중단 ( 랜선 절단, 전원 공급 중단)
- 예외(Exception) : 프로그래머 실행 중에 발생할 수 있는 가벼운 사건, 프로그램적으로 얼마든지 처리할 수 있는 오류 (숫자 0으로 나누기, 배열의 길이를 넘어섬)
- 자바는 예외 또한 객체로 처리함, 예외상황에 따라 다양한 예외 클래스를 제공하고 있음
- 자바가상머신이 기본 예외처리 핸들러가 예외를 잡아서 프로그램에게 다시보내 중단시킴
- 예외 클래스들은 java.lang.Throwable의 자식 클래스인 java.lang.Exception 클래스의 자식임
- java.lang.Error은 java.lang.Throwable의 자식이며 치명적인 에러를 뜻함
- java.lang.RuntimeException은 예외 처리 로직을 하지않아도 자동으로 에러를 보내줌
- runtimeException의 자식 이외의 오류들은 예외처리 로직을 놓지않으면 에러 안보냄
> 예외 클래스의 예시

| 예외                      | 종류                                                         |
| ------------------------- | ------------------------------------------------------------ |
| ArithmeticException       | 정수를 0으로 나누는 산술 연산 오류                           |
| IndexOutOfBoundsException | 배열의 인덱스가 배열의 길이를 넘어서면 발생하는 오류         |
| IllegalArgumentException  | 메서드의 매개변수 유형을 잘못 사용하면 발생하는 오류         |
| IOException               | 입출력 시에 지정한 파일이 시스템에 존재하지 않으면 발생하는 오류 |

#### 예외 처리
- 예외처리 방법 1) : 예외가 발생한 메서드 내에서 직접 처리하는 방식
	- try-catch 구문, 다중 catch 블록, 상속을 이용한 예외 처리, finally 블록
- 예외처리 방법 2) : 해당메서드를 호출한 곳으로 예외 처리를 넘기는 방식
	- throws 예약어 이용
1) try-catch 구문
> try-catch 구문
```Java
try {
	예외 발생 가능이 있는 소스코드;
}catch(예외 타입 매개변수명) {
	예외타입의 예외가 발생할 경우 수행될 소스코드;
}
// 지정한 예외타입이 발생하면 try블록 명령이 멈추고 즉시 catch 블록이 실행됨
```
* try 블록
	- 프로그래머가 프로그램 중에서 예외가 발생할 수 있는 소스코드들을 try 블록 안에 작성함
	- try 블록은 최소한 하나의 catch 블록이 있어야함
* catch 블록
	- try 블록 다음에 위치함
	- catch 블록의 매개변수는 예외 객체가 발생했을 때 참조하는 변수명, 반드시 java.lang.Throwable 클래스의 하위 클래스 타입으로 선언되어야 함.

2) 다중 catch 구문
- 프로그램에서 발생하는 예외에 따라 여러개의 예외 분기를 처리함
> 다중 catch 구문
```Java
try {
	예외 발생 가능이 있는 소스코드;
}catch(예외 타입1 매개변수명) {
	예외타입1의 예외가 발생할 경우 수행될 소스코드;
}catch(예외 타입n 매개변수명) {
	예외타입n의 예외가 발생할 경우 수행될 소스코드;
}
```
- try 블록 내에서 발생되는 모든 예외에 대해서 적절한 예외 처리 로직이 수행되도록 함

3) 상속을 이용한 예외 처리
- 모든 예외클래스는 Exception 클래스의 자식클래스임.
- 이러한 성질을 이용하여 형변환에 의해 Exception 타입의 변수로 할당 가능
- 즉, 모든 예외를 하나의 catch 블록으로도 처리할 수 있음
> 상속을 이용한 예외처리 예시
```Java
try {
	예외 발생 가능이 있는 소스코드;
}catch(Exception e) {
	예외타입의 예외가 발생할 경우 수행될 소스코드;
}
// 모든 예외가 Exception e로 간주되어 catch 구문을 실행시킴,
```
- 구체적으로 어떤 예외가 발생했는지 알 수 없음, 예외 처리 로직을 분기 처리할 수 없음
- 즉 왠만한 예외는 Exception catch 블록 앞에서 미리 잡도록 하고 분기 처리하며, 맨마지막에 Exception e를 잡도록 해서 기타 예외를 처리하도록 하면 좋음

4) finally 블록
- try-catch 구문에 추가할 수 있으며, 예외가 생기든 안생기든 무조건 수행되는 구문을 나타낸다
- 반드시 수행되어야 할 로직이 있는 경우에 finally 블록을 사용한다.
>finally 구문
```Java
try{
	예외 발생 가능이 있는 코드;
} catch(예외타입 매개변수명){
	예외타입의 예외가 발생할 경우 수행될 코드;
} finally {
	예외 발생 여부와 무관하게 무조건 수행될 코드;
}
```

5) throws 예약어
- 예외 발생 지점이 아닌, 에외가 발생한 메서드를 호출한 지점으로 예외를 전달하여 처리하는 방법
> throws 예약어 구문
```Java
[modifiers] returnType 메서드명([argType argName, ...]) [throws exceptionName1, exceptionName2, .....]//throws 예약어와 현재 발생한 예외 객체의 클래스 이름을 나열함
```
- 예외가 발생하면 이 메서드를 호출됬던 부분도 예외가 발생되며, 그곳에서 예외처리 로직을 추가하여 처리할 수 있음
- 발생된 예외 객체가 RuntimeException의 자식클래스인 경우 자동으로 Throw 됨
### 사용자 정의 예외
#### 사용자 정의 예외 처리
- API에서 제공하지 않는 예외클래스를 제공해서 사용할 수 있음
- 모든 예외클래스의 최상위 클래스인 java.lang.Exception 클래스를 상속받아 정의함
> 사용자 정의 예외 예시
```Java
class 예외클래스명 extends Exception

이후 정의된 예외는
throw new 예외클래스명(); 을 통해 예외를 발생시킬 수 있음
```
- 사용자 정의 예외는 throw new 예외클래스()를 이용하지 않으면 예외가 잡히지 않음