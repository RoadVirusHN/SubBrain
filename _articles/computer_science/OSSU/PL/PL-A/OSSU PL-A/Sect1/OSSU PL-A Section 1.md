---
title: OSSU PL-A Section 1
date: 2023-03-18 14:16:32 +0900
tags: HIDE CRUDE 
layout: obsidian
is_Finished: false
last_Reviewed: 2023-03-18 14:16:32 +0900
use_Mathjax: true
---

```ad-quote
출처 강의 [Programming Languages, Part A, 워싱턴 대학교](https://www.coursera.org/learn/programming-languages/home/welcome)
```
```toc
style: number
min_depth: 2
max_depth: 3
varied_style: true
```
# OSSU PL-A Section 1
프로그래밍 언어를 배울 때는 다음과 같은 부분을 배우는 것이다.
- **문법 (Syntax)**: 어떻게 동작을 표현하는 가? (ex) `int x = 3;`)
- **의미 (Semantics)**: 해당 기능을 어떤식으로 구현하는가? (ex) `x`가 메모리에 저장되는 과정)
- **관용구 (Idioms)**: 해당 동작을 위한 표현을 어떤 식으로 접근하는가, 일종의 문법의 모음 (ex) 특정 List를 순회하기 위해 파이썬은 `for` 문을, `Racket`은 재귀를 많이 이용함.)
- **라이브러리(Libraries)**: 이미 지원하고 있는 코드나 특정 기능을 사용하기 위해 필수적으로 사용하는 라이브러리(ex) 파일 접근을 위한 `os` 라이브러리)
- **도구들(Tools)**: 프로그램을 구현하는데 사용되는 도구들 (ex) 컴파일러, 디버거, 대화형 도구 등)

프로그래밍을 배울 때 많은 사람들은 문법(Syntax), 라이브러리만 강조하는 경우가 많지만 정말 중요한 부분은 의미(semantics)와 관용구(idioms)다.

## 표현과 변수 바인딩(Expression and Variable Bindings)

프로그램은 바인딩의 나열로 이루어지며, 각 **바인딩은 타입 확인 이후 평가(evaluate) 과정**을 거친다.

### 문법(syntax)
많은 프로그래밍 언어에서 다음과 같은 방법으로 바인딩을 표현한다.
```sml
val x = e;
```
- `val`은 키워드 `x`는 변수명, `e`는 표현이며, PL에 따라 `;`를 생략하기도 한다.
### 의미(semantics)
**정적 환경(static environment)은 바인딩의 타입을, 동적 환경(dynamic environment)은 바인딩의 값을 저장**한다.
여기서 말하는 정적 환경은 보통 `context`로, 동적 환경은 `Environment`로 많이 칭해진다.

1. 바인딩의 타입확인과 평가(Evaluation)을 진행
- 이전 동적 환경를 이용해 표현 `e`의 결과 값을 생성
- 이전 정적 환경를 이용해 표현 `e`의 타입을 확인
2. 해당 타입을 새로 환경에 추가
- `x`의 타입을 `e`의 타입 확인 결과인 `t`로 매핑하여 새로운 정적 환경 생성
- ` x`의 값을 e의 결과값인 `v`로 매핑하여 새로운 동적 환경 생성
	- 이때 `v`는 더 이상 계산하지 않아도 되는 값으로 매핑 됨.
### 예시
다음과 같은 프로그램을 예시로 들어보자.
```sml
val x = 1;
val y = 2;
val z = x + y; (* 바인딩 진행 *)
```
- 이전 동적 환경(`x = 1, y = 2`)를 이용해 `e(x + y)`가 평가되어 새로운 동적 환경 `(x = 1, y = 2, z = 3)`이 변경된다.
	- 이때 새로운 값 `x + y`는 더이상 계산이 필요치 않도록 `1 + 2`가 아닌 `3`으로 평가되어 저장
- 이전 정적 환경 `(x = int, y = int)`를 이용해 `int + int`가 `int`로 평가되어 새로운 정적 환경 `(x = int, y = int, z = int)`로 변경된다.

이렇게 생성된 바인딩은 수정되지 못하지만, 대신 덮어씌어질 수 있다.
따라서, `val f = z` 바인딩 이후, `val f = 4` 바인딩이 추가되면, `f`는 4가 되지만, `z`는 여전히 이전과 같다.

추가적인 예를 들어보자
- 조건 분기문
	- 문법 : `if e1 then e2 else e3` (`e1, e2, e3`는 표현)
	- 타입 확인: `e1`은 조건문에서 `bool` 타입이 들어가는 자리며, `e2`, `e3`는 서로 같은 타입 `t`(아무 타입이나 가능)이다. 추가로 정적 환경을 확인하여 타입을 확인
	- 평가: 동적 환경을 확인 결과, `e1`의 결과 값이 `true`이면 `e2`값이 동적 환경 하에 평가되어 해당 바인딩의 결과값으로 저장됨. 반대로 `false`이면 `e3`가 대상.

## 함수 바인딩
함수는 **결과를 내는 표현과 이에 사용되는 인자들**이며, 아래와 비슷하게 표현된다.
### 문법(syntax)
```sml
fun x0 (x1: t1, ..., xn: tn) = e
```
- 함수 바인딩 이름은 `x0`
- 각 인수는 `x1`~`xn`으로 매핑되며, 각 타입을 `t1`~`tn`으로 정적 환경에 매핑된다.
- 결과값 `e` 

### 의미(semantics)
#### 타입 확인
**표현 `e`는 앞선 정적 환경과 명시된 인자들의 타입들을 통해 타입 `t`로 유추**된다.
즉, `x0` 함수의 타입 `t1 * ... * tn -> t`로 정적환경에 매핑 된다.
- `*`는 `SML`에서 각 인자를 나누는데 사용되는 표현
여기서 각 인자 `x1,...xn`의 정적 환경값 `t1,...,tn`은 **전역 정적 환경에 저장되지 않고 해당 함수만 사용하는 지역 정적 환경에 저장**된다.
#### 평가
함수 바인딩의 평가는 바로 평가되지 않고 함수가 호출(called)될때 평가된다. 이를 통해 재귀 함수 등이 가능하게 된다.
### 함수 호출(Function calls)
함수 호출은 `x0 (e1,...,en)`의 형식으로 이루어진다.
타입 확인의 경우,
- `x0`의 타입이 `t1 * ... * tn -> t`일 경우 전체 함수 호출의 타입은 `t`로 정해진다.
평가의 경우
- 각 표현 `e1,...,en`이 먼저 `v1,...,vn`으로 평가된 후, 이 값을 통해 전체 함수 결과 `e`가 `v`로 평가된다.
- 이때 전체 함수에 평가되는 정적, 동적 환경은 어느 시기의 것일까? 함수를 정의할 때? 함수를 호출할 때? 이는 나중에 `lexical scope`로 배우게 된다.


## `pair`와 `tuple`

여러 데이터를 같이 묶은 복합 데이터를 구현하기 위해 `pair`나 `tuple`을 지원한다.
보통 다음과 같이 바인딩 된다.
```sml
val x = (e1, ... ,en) (* x = t1*...*tn 으로 정적 환경에 매핑*)
(*표현은 x = (v1,...,vn) 처럼 나뉘어 매핑*)
```
내부에는 다양한 타입의 표현이 들어갈 수 있으며 `tuple` 또한 가능하다.
- 이때는 `x = (t0 * t1)*...*tn` 같이 괄호를 이용해 매핑된다.
수가 둘인 `tuple`을 `pair`라고 한다.

사실, 함수의 인자들은 일종의 하나의 튜플로 취급된다.

## List
리스트를 이용하면, 특정 수가 아닌 임의의 수의 데이터를 이용할 수 있다. 단, 튜플과 달리 하나의 타입만 들어간다.

리스트 내에 다른 리스트 또한 들어갈 수 있다.

비어있는 리스트는 `[]`로 표현되며, `a' list`로 정적환경에 매핑되며, `a'`는 모든 타입을 의미하는 임시 값으로, 모든 값들이 리스트로 들어갈 수 있다.

값이 존재하는 리스트 `[e1, ..., en]`은 
- `[v1, ...., vn]`의 형태로 동적 환경에 매핑
- 이때 `e1,..., en`은 전부 같은 타입이여야 하며, 이를 `t0`로 놓으면 정적환경에 `t0 list` 타입으로 매핑된다.

## 지역 변수
함수 내에 새로운 바인딩을 사용하면, 해당 바인딩들은 기존의 전역 환경을 이용할 수 있지만, 함수내 지역 바인딩들은 함수 내에서의 사용으로만 국한된다.

이를 통해 코드의 가독성을 늘리고, 변수명의 중복을 피할 수 있다.

## Options
값이 존재하는 경우(`SOME`)와 존재하지 않는 경우(`NONE`)를 구분하여 넣을 수 있게 해주며, `t option` 형식으로 정적 환경에 매핑된다.
`null`, `isSome`의 함수로 `NONE`인지 확인 할 수 있으며,`valOf` 등으로 값을 가져올 수 있다.

## 변경(Mutation)의 부재와 이로 인한 이득

프로그래밍 언어들은 바인딩 들의 값을 변경할 수 없게 만든 경우와 변경 가능한 경우로 나뉜다.

장단점이 있지만 변경(Mutation)이 불가능하면 값에 대한 원본 값에 수정 접근 보안을 구현하기 쉽고, 공유하는 값, 참조하는 값의 변경으로 인한 예상치 못한 결과를 예방할 수 있다.

함수형 프로그래밍들은 보통 변경이 불가능하게 되어 있으며, Java와 같이 변경 가능한 경우도 존재한다.
- 그래서 자바의 경우는 값들의 참조와 복사 여부를 일일이 신경써야하지만 함수형 프로그래밍은 그렇지 않아도 된다.


