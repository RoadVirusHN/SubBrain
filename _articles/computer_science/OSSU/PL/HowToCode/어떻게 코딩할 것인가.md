---
title: 어떻게 코딩할 것인가
date: 2022-12-28 20:49:46 +0900
tags: CRUDE ETC OSSU PL
layout: obsidian
is_Finished: false
last_Reviewed: 2022-12-28 20:49:46 +0900
use_Mathjax: true
---

```toc
style: number
min_depth: 2
max_depth: 3
varied_style: true
```

# 어떻게 코딩할 것인가?

```ad-quote
Edx 강의 [_How to Code_](https://learning.edx.org/course/course-v1:UBCx+HtC1x+2T2017/home) 시리즈를 정리한 내용입니다.
```

- **좋은 프로그램이란?**
	- 잘 테스트된 여러 조각의 유기적인 작은 프로그램으로 이루어져 있으며 쉽게 추가, 수정 할 수 있으며, 원하는 목적을 잘 수행하는 프로그램
	
 - **좋은 프로그램을 만들기 어려운 이유**
		- 프로그램의 목적을 정의하기 모호하거나 계속 바뀌는 경우가 많음
		- 어려운 문제 하나를 쉬운 문제 여러개로 정확히 나누기 힘듦

"좋은 프로그래밍 설계란, **애매모호하고 어설프게 나누어진 문제들을 잘 구성된 하나의 솔루션으로 바꾸는 과정**이다."

## [[어떻게 코딩할 것인가-함수 설계]]
### [[어떻게 코딩할 것인가-캡슐화]]
## [[어떻게 코딩할 것인가-데이터 설계]]

## [[어떻게 코딩할 것인가-세계 설계]]
### [[스페이스 인베이더-세계 설계 예시 프로젝트]]

## 기타 팁
- 같은 인자값을 이용하는 함수의 경우, 오직 재귀함수인 경우에만 변수를 이용하자. 
	- 컴파일러가 알아서 동일한 결과를 변수로 바꿔준다.
- 람다식은 아래 두 조건이 충족될 경우에만 사용하여야 가독성에 영향을 주지 않음
	- 해당 함수 코드가 그 곳이외에는 사용되지 않음
	- 함수의 바디(로직)이 함수 이름을 짓는것보다 명확해 보일 때
- 꼬리 재귀(Tail recursion) 사용하기 : 재귀 함수의 결과값에 추가적인 연산을 하지말자!	
	- 재귀 함수의 결과값에 추가적인 연산을 하기 위해 스택 메모리에 결과값과 그에 대한 연산을 저장하게 된다.
	- 이는 엄청난 메모리와 성능 낭비를 야기시킨다.
	- 꼬리 재귀는 [[어떻게 코딩할 것인가-함수 설계#축적자(Accumulator)|축적자]]같은 추가적인 인자와 전처리를 통해 생성할 수 있다.
```ad-example
title: 꼬리 재귀 예시
~~~bsl
(define (sum lon)
	(cond [(empty? lon) 0]
		[else
			(+ (first lon) (sum (rest lon)))]))

;; 축적자를 통한 꼬리재귀 버전의 합 함수, 성능상 유리
(define (sum_tail lon0)
	(local [(define (sum lon acc)
				(cond [(empty? lon) acc]
					[else
						(sum (rest lon) (+ acc (first lon)))])]
	(sum lon0 0)))
~~~
```
```ad-warning
title: 단! 파이썬 컴파일러의 경우 꼬리재귀 함수의 최적화 과정을 디버깅의 용이성을 위해 지원하지 않으므로 의미없다!
```
